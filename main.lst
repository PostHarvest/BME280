CCS PCH C Compiler, Version 5.025, 40073               15-Thg10-17 14:48

               Filename:   D:\du lieu\BSD\BSD datasheet\BME280\REPORT SHT BME280 TRANSFER\main.lst

               ROM used:   12094 bytes (74%)
                           Largest free fragment is 4286
               RAM used:   135 (18%) at main() level
                           205 (27%) worst case
               Stack used: 5 locations (4 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   26F6
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00AE
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                            EX_CAN.C                             //// 
.................... ////                                                                 //// 
.................... //// Example of CCS's CAN library, using the PIC18Fxx8.  This        //// 
.................... //// example was tested using MCP250xxx CAN Developer's Kit.         //// 
.................... ////                                                                 //// 
.................... //// Connect pin B2 (CANTX) to the CANTX pin on the open NODE A of   //// 
.................... //// the developer's kit, and connect pin B3 (CANRX) to the CANRX    //// 
.................... //// pin on the open NODE A.                                         //// 
.................... ////                                                                 //// 
.................... //// NODE B has an MCP250xxx which sends and responds certan canned  //// 
.................... //// messages.  For example, hitting one of the GPX buttons on       //// 
.................... //// the development kit causes the MCP250xxx to send a 2 byte       //// 
.................... //// message with an ID of 0x290.  After pressing one of those       //// 
.................... //// buttons with this firmware you should see this message          //// 
.................... //// displayed over RS232.                                           //// 
.................... ////                                                                 //// 
.................... //// NODE B also responds to certain CAN messages.  If you send      //// 
.................... //// a request (RTR bit set) with an ID of 0x18 then NODE B will     //// 
.................... //// respond with an 8-byte message containing certain readings.     //// 
.................... //// This firmware sends this request every 2 seconds, which NODE B  //// 
.................... //// responds.                                                       //// 
.................... ////                                                                 //// 
.................... //// If you install Microchip's CANKing software and use the         //// 
.................... //// MCP250xxx , you can see all the CAN traffic and validate all    //// 
.................... //// experiments.                                                    //// 
.................... ////                                                                 //// 
.................... //// For more documentation on the CCS CAN library, see can-18xxx8.c //// 
.................... ////                                                                 //// 
.................... ////  Jumpers:                                                       //// 
.................... ////     PCM,PCH    pin C7 to RS232 RX, pin C6 to RS232 TX           //// 
.................... ////                                                                 //// 
.................... ////  This example will work with the PCM and PCH compilers.         //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <18F248.h> 
.................... //////////// Standard Header file for the PIC18F248 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F248 
*
00BA:  DATA 0D,0A
00BC:  DATA 0D,0A
00BE:  DATA 43,43
00C0:  DATA 53,20
00C2:  DATA 43,41
00C4:  DATA 4E,20
00C6:  DATA 54,52
00C8:  DATA 41,4E
00CA:  DATA 53,46
00CC:  DATA 45,52
00CE:  DATA 20,42
00D0:  DATA 4D,45
00D2:  DATA 32,38
00D4:  DATA 30,20
00D6:  DATA 44,41
00D8:  DATA 54,41
00DA:  DATA 0D,0A
00DC:  DATA 00,00
00DE:  DATA 0D,0A
00E0:  DATA 52,75
00E2:  DATA 6E,6E
00E4:  DATA 69,6E
00E6:  DATA 67,2E
00E8:  DATA 2E,2E
00EA:  DATA 00,00
00EC:  DATA 0D,0A
00EE:  DATA 54,65
00F0:  DATA 6D,70
00F2:  DATA 5F,42
00F4:  DATA 4D,45
00F6:  DATA 32,38
00F8:  DATA 30,20
00FA:  DATA 3D,20
00FC:  DATA 25,66
00FE:  DATA 33,00
0100:  DATA 0D,0A
0102:  DATA 48,75
0104:  DATA 6D,69
0106:  DATA 64,69
0108:  DATA 74,79
010A:  DATA 42,4D
010C:  DATA 45,32
010E:  DATA 38,30
0110:  DATA 20,3D
0112:  DATA 20,25
0114:  DATA 66,33
0116:  DATA 00,00
0118:  DATA 0D,0A
011A:  DATA 54,50
011C:  DATA 72,65
011E:  DATA 73,73
0120:  DATA 42,4D
0122:  DATA 45,32
0124:  DATA 38,30
0126:  DATA 20,3D
0128:  DATA 20,25
012A:  DATA 66,33
012C:  DATA 00,00
012E:  DATA 0D,0A
0130:  DATA 47,4F
0132:  DATA 54,3A
0134:  DATA 20,42
0136:  DATA 55,46
0138:  DATA 46,3D
013A:  DATA 25,55
013C:  DATA 20,49
013E:  DATA 44,3D
0140:  DATA 25,4C
0142:  DATA 55,20
0144:  DATA 4C,45
0146:  DATA 4E,3D
0148:  DATA 25,55
014A:  DATA 20,4F
014C:  DATA 56,46
014E:  DATA 3D,25
0150:  DATA 55,20
0152:  DATA 00,00
0154:  DATA 46,49
0156:  DATA 4C,54
0158:  DATA 3D,25
015A:  DATA 55,20
015C:  DATA 52,54
015E:  DATA 52,3D
0160:  DATA 25,55
0162:  DATA 20,45
0164:  DATA 58,54
0166:  DATA 3D,25
0168:  DATA 55,20
016A:  DATA 49,4E
016C:  DATA 56,3D
016E:  DATA 25,55
0170:  DATA 00,00
0172:  DATA 0D,0A
0174:  DATA 20,20
0176:  DATA 20,20
0178:  DATA 44,41
017A:  DATA 54,41
017C:  DATA 20,3D
017E:  DATA 20,00
0180:  DATA 0D,0A
0182:  DATA 46,41
0184:  DATA 49,4C
0186:  DATA 20,6F
0188:  DATA 6E,20
018A:  DATA 47,45
018C:  DATA 54,44
018E:  DATA 0D,0A
0190:  DATA 00,00
0192:  DATA 0D,0A
0194:  DATA 50,55
0196:  DATA 54,20
0198:  DATA 25,55
019A:  DATA 3A,20
019C:  DATA 49,44
019E:  DATA 3D,25
01A0:  DATA 4C,55
01A2:  DATA 20,4C
01A4:  DATA 45,4E
01A6:  DATA 3D,25
01A8:  DATA 55,20
01AA:  DATA 00,00
01AC:  DATA 50,52
01AE:  DATA 49,3D
01B0:  DATA 25,55
01B2:  DATA 20,45
01B4:  DATA 58,54
01B6:  DATA 3D,25
01B8:  DATA 55,20
01BA:  DATA 52,54
01BC:  DATA 52,3D
01BE:  DATA 25,55
01C0:  DATA 0D,0A
01C2:  DATA 20,20
01C4:  DATA 20,44
01C6:  DATA 41,54
01C8:  DATA 41,20
01CA:  DATA 3D,20
01CC:  DATA 00,00
01CE:  DATA 0D,0A
01D0:  DATA 46,41
01D2:  DATA 49,4C
01D4:  DATA 20,6F
01D6:  DATA 6E,20
01D8:  DATA 50,55
01DA:  DATA 54,44
01DC:  DATA 0D,0A
01DE:  DATA 00,00
01E0:  DATA 0D,0A
01E2:  DATA 50,55
01E4:  DATA 54,20
01E6:  DATA 25,55
01E8:  DATA 3A,20
01EA:  DATA 49,44
01EC:  DATA 3D,25
01EE:  DATA 4C,55
01F0:  DATA 20,4C
01F2:  DATA 45,4E
01F4:  DATA 3D,25
01F6:  DATA 55,20
01F8:  DATA 00,00
01FA:  DATA 50,52
01FC:  DATA 49,3D
01FE:  DATA 25,55
0200:  DATA 20,45
0202:  DATA 58,54
0204:  DATA 3D,25
0206:  DATA 55,20
0208:  DATA 52,54
020A:  DATA 52,3D
020C:  DATA 25,55
020E:  DATA 0D,0A
0210:  DATA 20,20
0212:  DATA 20,44
0214:  DATA 41,54
0216:  DATA 41,20
0218:  DATA 3D,20
021A:  DATA 00,00
021C:  TBLRD*+
021E:  MOVF   FF5,F
0220:  BZ    023C
0222:  MOVFF  FF6,A3
0226:  MOVFF  FF7,A4
022A:  MOVF   FF5,W
022C:  BTFSS  F9E.4
022E:  BRA    022C
0230:  MOVWF  FAD
0232:  MOVFF  A3,FF6
0236:  MOVFF  A4,FF7
023A:  BRA    021C
023C:  RETURN 0
*
060C:  MOVF   xB4,W
060E:  MULWF  xB6
0610:  MOVFF  FF3,01
0614:  MOVFF  FF4,00
0618:  MULWF  xB7
061A:  MOVF   FF3,W
061C:  ADDWF  00,F
061E:  MOVF   xB5,W
0620:  MULWF  xB6
0622:  MOVF   FF3,W
0624:  ADDWFC 00,W
0626:  MOVWF  02
0628:  GOTO   069A (RETURN)
*
0966:  CLRF   xC7
0968:  CLRF   xC8
096A:  MOVLW  01
096C:  MOVWF  xC9
096E:  CLRF   FDA
0970:  CLRF   FD9
0972:  CLRF   xCC
0974:  MOVLW  BF
0976:  MOVWF  xCB
0978:  CLRF   FEA
097A:  MOVLW  C3
097C:  MOVWF  FE9
097E:  MOVFF  CC,FE2
0982:  MOVFF  CB,FE1
0986:  MOVFF  C9,CA
098A:  BCF    FD8.0
098C:  MOVF   FE5,W
098E:  MULWF  FEE
0990:  MOVF   FF3,W
0992:  ADDWFC xC7,F
0994:  MOVF   FF4,W
0996:  ADDWFC xC8,F
0998:  DECFSZ xCA,F
099A:  BRA    098A
099C:  MOVFF  C7,FDE
09A0:  MOVFF  C8,C7
09A4:  CLRF   xC8
09A6:  BTFSC  FD8.0
09A8:  INCF   xC8,F
09AA:  INCF   xCB,F
09AC:  BTFSC  FD8.2
09AE:  INCF   xCC,F
09B0:  INCF   xC9,F
09B2:  MOVF   xC9,W
09B4:  SUBLW  05
09B6:  BNZ   0978
09B8:  RETURN 0
09BA:  MOVLW  B6
09BC:  MOVWF  00
09BE:  CLRF   03
09C0:  CLRF   02
09C2:  CLRF   01
09C4:  MOVF   xB4,W
09C6:  IORWF  xB5,W
09C8:  IORWF  xB6,W
09CA:  IORWF  xB7,W
09CC:  BNZ   09D2
09CE:  CLRF   00
09D0:  BRA    09EC
09D2:  BCF    FD8.0
09D4:  BTFSC  01.7
09D6:  BRA    09EA
09D8:  RLCF   xB4,F
09DA:  RLCF   xB5,F
09DC:  RLCF   xB6,F
09DE:  RLCF   xB7,F
09E0:  RLCF   03,F
09E2:  RLCF   02,F
09E4:  RLCF   01,F
09E6:  DECFSZ 00,F
09E8:  BRA    09D2
09EA:  BCF    01.7
09EC:  RETURN 0
09EE:  MOVF   xB3,W
09F0:  BTFSC  FD8.2
09F2:  BRA    0B3E
09F4:  MOVWF  xBF
09F6:  MOVF   xB7,W
09F8:  BTFSC  FD8.2
09FA:  BRA    0B3E
09FC:  SUBWF  xBF,F
09FE:  BNC   0A0A
0A00:  MOVLW  7F
0A02:  ADDWF  xBF,F
0A04:  BTFSC  FD8.0
0A06:  BRA    0B3E
0A08:  BRA    0A16
0A0A:  MOVLW  81
0A0C:  SUBWF  xBF,F
0A0E:  BTFSS  FD8.0
0A10:  BRA    0B3E
0A12:  BTFSC  FD8.2
0A14:  BRA    0B3E
0A16:  MOVFF  BF,00
0A1A:  CLRF   01
0A1C:  CLRF   02
0A1E:  CLRF   03
0A20:  CLRF   xBE
0A22:  MOVFF  B4,BD
0A26:  BSF    xBD.7
0A28:  MOVFF  B5,BC
0A2C:  MOVFF  B6,BB
0A30:  MOVLW  19
0A32:  MOVWF  xBF
0A34:  MOVF   xBA,W
0A36:  SUBWF  xBB,F
0A38:  BC    0A54
0A3A:  MOVLW  01
0A3C:  SUBWF  xBC,F
0A3E:  BC    0A54
0A40:  SUBWF  xBD,F
0A42:  BC    0A54
0A44:  SUBWF  xBE,F
0A46:  BC    0A54
0A48:  INCF   xBE,F
0A4A:  INCF   xBD,F
0A4C:  INCF   xBC,F
0A4E:  MOVF   xBA,W
0A50:  ADDWF  xBB,F
0A52:  BRA    0AA4
0A54:  MOVF   xB9,W
0A56:  SUBWF  xBC,F
0A58:  BC    0A7E
0A5A:  MOVLW  01
0A5C:  SUBWF  xBD,F
0A5E:  BC    0A7E
0A60:  SUBWF  xBE,F
0A62:  BC    0A7E
0A64:  INCF   xBE,F
0A66:  INCF   xBD,F
0A68:  MOVF   xB9,W
0A6A:  ADDWF  xBC,F
0A6C:  MOVF   xBA,W
0A6E:  ADDWF  xBB,F
0A70:  BNC   0AA4
0A72:  INCF   xBC,F
0A74:  BNZ   0AA4
0A76:  INCF   xBD,F
0A78:  BNZ   0AA4
0A7A:  INCF   xBE,F
0A7C:  BRA    0AA4
0A7E:  MOVF   xB8,W
0A80:  IORLW  80
0A82:  SUBWF  xBD,F
0A84:  BC    0AA2
0A86:  MOVLW  01
0A88:  SUBWF  xBE,F
0A8A:  BC    0AA2
0A8C:  INCF   xBE,F
0A8E:  MOVF   xB8,W
0A90:  IORLW  80
0A92:  ADDWF  xBD,F
0A94:  MOVF   xB9,W
0A96:  ADDWF  xBC,F
0A98:  BNC   0A6C
0A9A:  INCF   xBD,F
0A9C:  BNZ   0A6C
0A9E:  INCF   xBE,F
0AA0:  BRA    0A6C
0AA2:  BSF    03.0
0AA4:  DECFSZ xBF,F
0AA6:  BRA    0AAA
0AA8:  BRA    0AC0
0AAA:  BCF    FD8.0
0AAC:  RLCF   xBB,F
0AAE:  RLCF   xBC,F
0AB0:  RLCF   xBD,F
0AB2:  RLCF   xBE,F
0AB4:  BCF    FD8.0
0AB6:  RLCF   03,F
0AB8:  RLCF   02,F
0ABA:  RLCF   01,F
0ABC:  RLCF   xC0,F
0ABE:  BRA    0A34
0AC0:  BTFSS  xC0.0
0AC2:  BRA    0AD0
0AC4:  BCF    FD8.0
0AC6:  RRCF   01,F
0AC8:  RRCF   02,F
0ACA:  RRCF   03,F
0ACC:  RRCF   xC0,F
0ACE:  BRA    0AD4
0AD0:  DECF   00,F
0AD2:  BZ    0B3E
0AD4:  BTFSC  xC0.7
0AD6:  BRA    0B14
0AD8:  BCF    FD8.0
0ADA:  RLCF   xBB,F
0ADC:  RLCF   xBC,F
0ADE:  RLCF   xBD,F
0AE0:  RLCF   xBE,F
0AE2:  MOVF   xBA,W
0AE4:  SUBWF  xBB,F
0AE6:  BC    0AF6
0AE8:  MOVLW  01
0AEA:  SUBWF  xBC,F
0AEC:  BC    0AF6
0AEE:  SUBWF  xBD,F
0AF0:  BC    0AF6
0AF2:  SUBWF  xBE,F
0AF4:  BNC   0B2A
0AF6:  MOVF   xB9,W
0AF8:  SUBWF  xBC,F
0AFA:  BC    0B06
0AFC:  MOVLW  01
0AFE:  SUBWF  xBD,F
0B00:  BC    0B06
0B02:  SUBWF  xBE,F
0B04:  BNC   0B2A
0B06:  MOVF   xB8,W
0B08:  IORLW  80
0B0A:  SUBWF  xBD,F
0B0C:  BC    0B14
0B0E:  MOVLW  01
0B10:  SUBWF  xBE,F
0B12:  BNC   0B2A
0B14:  INCF   03,F
0B16:  BNZ   0B2A
0B18:  INCF   02,F
0B1A:  BNZ   0B2A
0B1C:  INCF   01,F
0B1E:  BNZ   0B2A
0B20:  INCF   00,F
0B22:  BZ    0B3E
0B24:  RRCF   01,F
0B26:  RRCF   02,F
0B28:  RRCF   03,F
0B2A:  MOVFF  B4,BF
0B2E:  MOVF   xB8,W
0B30:  XORWF  xBF,F
0B32:  BTFSS  xBF.7
0B34:  BRA    0B3A
0B36:  BSF    01.7
0B38:  BRA    0B46
0B3A:  BCF    01.7
0B3C:  BRA    0B46
0B3E:  CLRF   00
0B40:  CLRF   01
0B42:  CLRF   02
0B44:  CLRF   03
0B46:  RETURN 0
*
0E82:  TBLRD*+
0E84:  MOVFF  FF6,A8
0E88:  MOVFF  FF7,A9
0E8C:  MOVF   FF5,W
0E8E:  BTFSS  F9E.4
0E90:  BRA    0E8E
0E92:  MOVWF  FAD
0E94:  MOVFF  A8,FF6
0E98:  MOVFF  A9,FF7
0E9C:  DECFSZ xA7,F
0E9E:  BRA    0E82
0EA0:  RETURN 0
0EA2:  MOVF   xB7,W
0EA4:  BTFSC  FD8.2
0EA6:  BRA    0F8A
0EA8:  MOVWF  00
0EAA:  MOVF   xBB,W
0EAC:  BTFSC  FD8.2
0EAE:  BRA    0F8A
0EB0:  ADDWF  00,F
0EB2:  BNC   0EBC
0EB4:  MOVLW  81
0EB6:  ADDWF  00,F
0EB8:  BC    0F8A
0EBA:  BRA    0EC4
0EBC:  MOVLW  7F
0EBE:  SUBWF  00,F
0EC0:  BNC   0F8A
0EC2:  BZ    0F8A
0EC4:  MOVFF  B8,BF
0EC8:  MOVF   xBC,W
0ECA:  XORWF  xBF,F
0ECC:  BSF    xB8.7
0ECE:  BSF    xBC.7
0ED0:  MOVF   xBA,W
0ED2:  MULWF  xBE
0ED4:  MOVFF  FF4,C1
0ED8:  MOVF   xB9,W
0EDA:  MULWF  xBD
0EDC:  MOVFF  FF4,03
0EE0:  MOVFF  FF3,C0
0EE4:  MULWF  xBE
0EE6:  MOVF   FF3,W
0EE8:  ADDWF  xC1,F
0EEA:  MOVF   FF4,W
0EEC:  ADDWFC xC0,F
0EEE:  MOVLW  00
0EF0:  ADDWFC 03,F
0EF2:  MOVF   xBA,W
0EF4:  MULWF  xBD
0EF6:  MOVF   FF3,W
0EF8:  ADDWF  xC1,F
0EFA:  MOVF   FF4,W
0EFC:  ADDWFC xC0,F
0EFE:  MOVLW  00
0F00:  CLRF   02
0F02:  ADDWFC 03,F
0F04:  ADDWFC 02,F
0F06:  MOVF   xB8,W
0F08:  MULWF  xBE
0F0A:  MOVF   FF3,W
0F0C:  ADDWF  xC0,F
0F0E:  MOVF   FF4,W
0F10:  ADDWFC 03,F
0F12:  MOVLW  00
0F14:  ADDWFC 02,F
0F16:  MOVF   xB8,W
0F18:  MULWF  xBD
0F1A:  MOVF   FF3,W
0F1C:  ADDWF  03,F
0F1E:  MOVF   FF4,W
0F20:  ADDWFC 02,F
0F22:  MOVLW  00
0F24:  CLRF   01
0F26:  ADDWFC 01,F
0F28:  MOVF   xBA,W
0F2A:  MULWF  xBC
0F2C:  MOVF   FF3,W
0F2E:  ADDWF  xC0,F
0F30:  MOVF   FF4,W
0F32:  ADDWFC 03,F
0F34:  MOVLW  00
0F36:  ADDWFC 02,F
0F38:  ADDWFC 01,F
0F3A:  MOVF   xB9,W
0F3C:  MULWF  xBC
0F3E:  MOVF   FF3,W
0F40:  ADDWF  03,F
0F42:  MOVF   FF4,W
0F44:  ADDWFC 02,F
0F46:  MOVLW  00
0F48:  ADDWFC 01,F
0F4A:  MOVF   xB8,W
0F4C:  MULWF  xBC
0F4E:  MOVF   FF3,W
0F50:  ADDWF  02,F
0F52:  MOVF   FF4,W
0F54:  ADDWFC 01,F
0F56:  INCF   00,F
0F58:  BTFSC  01.7
0F5A:  BRA    0F66
0F5C:  RLCF   xC0,F
0F5E:  RLCF   03,F
0F60:  RLCF   02,F
0F62:  RLCF   01,F
0F64:  DECF   00,F
0F66:  MOVLW  00
0F68:  BTFSS  xC0.7
0F6A:  BRA    0F80
0F6C:  INCF   03,F
0F6E:  ADDWFC 02,F
0F70:  ADDWFC 01,F
0F72:  MOVF   01,W
0F74:  BNZ   0F80
0F76:  MOVF   02,W
0F78:  BNZ   0F80
0F7A:  MOVF   03,W
0F7C:  BNZ   0F80
0F7E:  INCF   00,F
0F80:  BTFSC  xBF.7
0F82:  BSF    01.7
0F84:  BTFSS  xBF.7
0F86:  BCF    01.7
0F88:  BRA    0F92
0F8A:  CLRF   00
0F8C:  CLRF   01
0F8E:  CLRF   02
0F90:  CLRF   03
0F92:  RETURN 0
0F94:  MOVF   xB0,W
0F96:  SUBLW  B6
0F98:  MOVWF  xB0
0F9A:  CLRF   03
0F9C:  MOVFF  B1,B4
0FA0:  BSF    xB1.7
0FA2:  BCF    FD8.0
0FA4:  RRCF   xB1,F
0FA6:  RRCF   xB2,F
0FA8:  RRCF   xB3,F
0FAA:  RRCF   03,F
0FAC:  RRCF   02,F
0FAE:  RRCF   01,F
0FB0:  RRCF   00,F
0FB2:  DECFSZ xB0,F
0FB4:  BRA    0FA2
0FB6:  BTFSS  xB4.7
0FB8:  BRA    0FD0
0FBA:  COMF   00,F
0FBC:  COMF   01,F
0FBE:  COMF   02,F
0FC0:  COMF   03,F
0FC2:  INCF   00,F
0FC4:  BTFSC  FD8.2
0FC6:  INCF   01,F
0FC8:  BTFSC  FD8.2
0FCA:  INCF   02,F
0FCC:  BTFSC  FD8.2
0FCE:  INCF   03,F
0FD0:  GOTO   10B0 (RETURN)
0FD4:  BTFSC  FD8.1
0FD6:  BRA    0FDE
0FD8:  CLRF   FEA
0FDA:  MOVLW  B9
0FDC:  MOVWF  FE9
0FDE:  CLRF   00
0FE0:  CLRF   01
0FE2:  CLRF   02
0FE4:  CLRF   03
0FE6:  CLRF   xB9
0FE8:  CLRF   xBA
0FEA:  CLRF   xBB
0FEC:  CLRF   xBC
0FEE:  MOVF   xB8,W
0FF0:  IORWF  xB7,W
0FF2:  IORWF  xB6,W
0FF4:  IORWF  xB5,W
0FF6:  BZ    1050
0FF8:  MOVLW  20
0FFA:  MOVWF  xBD
0FFC:  BCF    FD8.0
0FFE:  RLCF   xB1,F
1000:  RLCF   xB2,F
1002:  RLCF   xB3,F
1004:  RLCF   xB4,F
1006:  RLCF   xB9,F
1008:  RLCF   xBA,F
100A:  RLCF   xBB,F
100C:  RLCF   xBC,F
100E:  MOVF   xB8,W
1010:  SUBWF  xBC,W
1012:  BNZ   1024
1014:  MOVF   xB7,W
1016:  SUBWF  xBB,W
1018:  BNZ   1024
101A:  MOVF   xB6,W
101C:  SUBWF  xBA,W
101E:  BNZ   1024
1020:  MOVF   xB5,W
1022:  SUBWF  xB9,W
1024:  BNC   1044
1026:  MOVF   xB5,W
1028:  SUBWF  xB9,F
102A:  MOVF   xB6,W
102C:  BTFSS  FD8.0
102E:  INCFSZ xB6,W
1030:  SUBWF  xBA,F
1032:  MOVF   xB7,W
1034:  BTFSS  FD8.0
1036:  INCFSZ xB7,W
1038:  SUBWF  xBB,F
103A:  MOVF   xB8,W
103C:  BTFSS  FD8.0
103E:  INCFSZ xB8,W
1040:  SUBWF  xBC,F
1042:  BSF    FD8.0
1044:  RLCF   00,F
1046:  RLCF   01,F
1048:  RLCF   02,F
104A:  RLCF   03,F
104C:  DECFSZ xBD,F
104E:  BRA    0FFC
1050:  MOVFF  B9,FEF
1054:  MOVFF  BA,FEC
1058:  MOVFF  BB,FEC
105C:  MOVFF  BC,FEC
1060:  RETURN 0
1062:  MOVF   FE9,W
1064:  MOVWF  xA8
1066:  MOVF   xA7,W
1068:  MOVWF  xAA
106A:  BZ    109E
106C:  MOVFF  A6,BA
1070:  MOVFF  A5,B9
1074:  MOVFF  A4,B8
1078:  MOVFF  A3,B7
107C:  CLRF   xBE
107E:  CLRF   xBD
1080:  MOVLW  20
1082:  MOVWF  xBC
1084:  MOVLW  82
1086:  MOVWF  xBB
1088:  RCALL  0EA2
108A:  MOVFF  03,A6
108E:  MOVFF  02,A5
1092:  MOVFF  01,A4
1096:  MOVFF  00,A3
109A:  DECFSZ xAA,F
109C:  BRA    106C
109E:  MOVFF  A6,B3
10A2:  MOVFF  A5,B2
10A6:  MOVFF  A4,B1
10AA:  MOVFF  A3,B0
10AE:  BRA    0F94
10B0:  MOVFF  03,A6
10B4:  MOVFF  02,A5
10B8:  MOVFF  01,A4
10BC:  MOVFF  00,A3
10C0:  BTFSS  xA6.7
10C2:  BRA    10DE
10C4:  DECF   xA8,F
10C6:  BSF    xA8.5
10C8:  COMF   xA3,F
10CA:  COMF   xA4,F
10CC:  COMF   xA5,F
10CE:  COMF   xA6,F
10D0:  INCF   xA3,F
10D2:  BTFSC  FD8.2
10D4:  INCF   xA4,F
10D6:  BTFSC  FD8.2
10D8:  INCF   xA5,F
10DA:  BTFSC  FD8.2
10DC:  INCF   xA6,F
10DE:  MOVLW  3B
10E0:  MOVWF  xAF
10E2:  MOVLW  9A
10E4:  MOVWF  xAE
10E6:  MOVLW  CA
10E8:  MOVWF  xAD
10EA:  CLRF   xAC
10EC:  MOVLW  0A
10EE:  MOVWF  xAA
10F0:  MOVF   xA7,W
10F2:  BTFSC  FD8.2
10F4:  INCF   xA8,F
10F6:  BSF    FD8.1
10F8:  CLRF   FEA
10FA:  MOVLW  A3
10FC:  MOVWF  FE9
10FE:  MOVFF  A6,B4
1102:  MOVFF  A5,B3
1106:  MOVFF  A4,B2
110A:  MOVFF  A3,B1
110E:  MOVFF  AF,B8
1112:  MOVFF  AE,B7
1116:  MOVFF  AD,B6
111A:  MOVFF  AC,B5
111E:  RCALL  0FD4
1120:  MOVF   01,W
1122:  MOVF   00,F
1124:  BNZ   1144
1126:  INCF   xA7,W
1128:  SUBWF  xAA,W
112A:  BZ    1144
112C:  MOVF   xA8,W
112E:  BZ    1148
1130:  ANDLW  0F
1132:  SUBWF  xAA,W
1134:  BZ    1138
1136:  BC    11AE
1138:  BTFSC  xA8.7
113A:  BRA    11AE
113C:  BTFSC  xA8.6
113E:  BRA    1148
1140:  MOVLW  20
1142:  BRA    11A4
1144:  MOVLW  20
1146:  ANDWF  xA8,F
1148:  BTFSS  xA8.5
114A:  BRA    1166
114C:  BCF    xA8.5
114E:  MOVF   xA7,W
1150:  BTFSS  FD8.2
1152:  DECF   xA8,F
1154:  MOVF   00,W
1156:  MOVWF  xA8
1158:  MOVLW  2D
115A:  BTFSS  F9E.4
115C:  BRA    115A
115E:  MOVWF  FAD
1160:  MOVF   xA8,W
1162:  MOVWF  00
1164:  CLRF   xA8
1166:  MOVF   xA7,W
1168:  SUBWF  xAA,W
116A:  BNZ   1182
116C:  MOVF   00,W
116E:  MOVWF  xA8
1170:  MOVLW  2E
1172:  BTFSS  F9E.4
1174:  BRA    1172
1176:  MOVWF  FAD
1178:  MOVF   xA8,W
117A:  MOVWF  00
117C:  MOVLW  20
117E:  ANDWF  xA8,F
1180:  MOVLW  00
1182:  MOVLW  30
1184:  BTFSS  xA8.5
1186:  BRA    11A4
1188:  BCF    xA8.5
118A:  MOVF   xA7,W
118C:  BTFSS  FD8.2
118E:  DECF   xA8,F
1190:  MOVF   00,W
1192:  MOVWF  xA8
1194:  MOVLW  2D
1196:  BTFSS  F9E.4
1198:  BRA    1196
119A:  MOVWF  FAD
119C:  MOVF   xA8,W
119E:  MOVWF  00
11A0:  CLRF   xA8
11A2:  MOVLW  30
11A4:  ADDWF  00,F
11A6:  MOVF   00,W
11A8:  BTFSS  F9E.4
11AA:  BRA    11A8
11AC:  MOVWF  FAD
11AE:  BCF    FD8.1
11B0:  MOVFF  AF,B4
11B4:  MOVFF  AE,B3
11B8:  MOVFF  AD,B2
11BC:  MOVFF  AC,B1
11C0:  CLRF   xB8
11C2:  CLRF   xB7
11C4:  CLRF   xB6
11C6:  MOVLW  0A
11C8:  MOVWF  xB5
11CA:  RCALL  0FD4
11CC:  MOVFF  03,AF
11D0:  MOVFF  02,AE
11D4:  MOVFF  01,AD
11D8:  MOVFF  00,AC
11DC:  DECFSZ xAA,F
11DE:  BRA    10F6
11E0:  RETURN 0
*
1786:  MOVLW  B6
1788:  MOVWF  00
178A:  CLRF   03
178C:  CLRF   02
178E:  CLRF   01
1790:  BCF    xB3.0
1792:  BTFSS  xB2.7
1794:  BRA    17AE
1796:  BSF    xB3.0
1798:  COMF   xAF,F
179A:  COMF   xB0,F
179C:  COMF   xB1,F
179E:  COMF   xB2,F
17A0:  INCF   xAF,F
17A2:  BNZ   17AE
17A4:  INCF   xB0,F
17A6:  BNZ   17AE
17A8:  INCF   xB1,F
17AA:  BTFSC  FD8.2
17AC:  INCF   xB2,F
17AE:  MOVF   xAF,W
17B0:  IORWF  xB0,W
17B2:  IORWF  xB1,W
17B4:  IORWF  xB2,W
17B6:  BNZ   17BC
17B8:  CLRF   00
17BA:  BRA    17DA
17BC:  BCF    FD8.0
17BE:  BTFSC  01.7
17C0:  BRA    17D4
17C2:  RLCF   xAF,F
17C4:  RLCF   xB0,F
17C6:  RLCF   xB1,F
17C8:  RLCF   xB2,F
17CA:  RLCF   03,F
17CC:  RLCF   02,F
17CE:  RLCF   01,F
17D0:  DECFSZ 00,F
17D2:  BRA    17BC
17D4:  BCF    01.7
17D6:  BTFSC  xB3.0
17D8:  BSF    01.7
17DA:  GOTO   1B92 (RETURN)
17DE:  MOVLW  80
17E0:  BTFSC  FD8.1
17E2:  XORWF  xB8,F
17E4:  CLRF   xBD
17E6:  CLRF   xBE
17E8:  MOVFF  B4,BC
17EC:  MOVF   xB8,W
17EE:  XORWF  xBC,F
17F0:  MOVF   xB3,W
17F2:  BTFSC  FD8.2
17F4:  BRA    19AE
17F6:  MOVWF  xBB
17F8:  MOVWF  00
17FA:  MOVF   xB7,W
17FC:  BTFSC  FD8.2
17FE:  BRA    19C0
1800:  SUBWF  xBB,F
1802:  BTFSC  FD8.2
1804:  BRA    1908
1806:  BNC   1882
1808:  MOVFF  B8,C1
180C:  BSF    xC1.7
180E:  MOVFF  B9,C0
1812:  MOVFF  BA,BF
1816:  CLRF   xBE
1818:  BCF    FD8.0
181A:  RRCF   xC1,F
181C:  RRCF   xC0,F
181E:  RRCF   xBF,F
1820:  RRCF   xBE,F
1822:  DECFSZ xBB,F
1824:  BRA    1816
1826:  BTFSS  xBC.7
1828:  BRA    1830
182A:  BSF    xBD.0
182C:  BRA    19E8
182E:  BCF    xBD.0
1830:  BCF    xBB.0
1832:  BSF    xBD.4
1834:  CLRF   FEA
1836:  MOVLW  B6
1838:  MOVWF  FE9
183A:  BRA    1A0E
183C:  BCF    xBD.4
183E:  BTFSC  xBC.7
1840:  BRA    1856
1842:  BTFSS  xBB.0
1844:  BRA    186C
1846:  RRCF   xC1,F
1848:  RRCF   xC0,F
184A:  RRCF   xBF,F
184C:  RRCF   xBE,F
184E:  INCF   00,F
1850:  BTFSC  FD8.2
1852:  BRA    19DE
1854:  BRA    186C
1856:  BTFSC  xC1.7
1858:  BRA    1872
185A:  BCF    FD8.0
185C:  RLCF   xBE,F
185E:  RLCF   xBF,F
1860:  RLCF   xC0,F
1862:  RLCF   xC1,F
1864:  DECF   00,F
1866:  BTFSC  FD8.2
1868:  BRA    19DE
186A:  BRA    1856
186C:  BSF    xBD.6
186E:  BRA    1946
1870:  BCF    xBD.6
1872:  MOVFF  B4,BC
1876:  BTFSS  xB4.7
1878:  BRA    187E
187A:  BSF    xC1.7
187C:  BRA    19D0
187E:  BCF    xC1.7
1880:  BRA    19D0
1882:  MOVFF  B7,BB
1886:  MOVFF  B7,00
188A:  MOVF   xB3,W
188C:  SUBWF  xBB,F
188E:  MOVFF  B4,C1
1892:  BSF    xC1.7
1894:  MOVFF  B5,C0
1898:  MOVFF  B6,BF
189C:  CLRF   xBE
189E:  BCF    FD8.0
18A0:  RRCF   xC1,F
18A2:  RRCF   xC0,F
18A4:  RRCF   xBF,F
18A6:  RRCF   xBE,F
18A8:  DECFSZ xBB,F
18AA:  BRA    189C
18AC:  BTFSS  xBC.7
18AE:  BRA    18B6
18B0:  BSF    xBD.1
18B2:  BRA    19E8
18B4:  BCF    xBD.1
18B6:  BCF    xBB.0
18B8:  BSF    xBD.5
18BA:  CLRF   FEA
18BC:  MOVLW  BA
18BE:  MOVWF  FE9
18C0:  BRA    1A0E
18C2:  BCF    xBD.5
18C4:  BTFSC  xBC.7
18C6:  BRA    18DC
18C8:  BTFSS  xBB.0
18CA:  BRA    18F2
18CC:  RRCF   xC1,F
18CE:  RRCF   xC0,F
18D0:  RRCF   xBF,F
18D2:  RRCF   xBE,F
18D4:  INCF   00,F
18D6:  BTFSC  FD8.2
18D8:  BRA    19DE
18DA:  BRA    18F2
18DC:  BTFSC  xC1.7
18DE:  BRA    18F8
18E0:  BCF    FD8.0
18E2:  RLCF   xBE,F
18E4:  RLCF   xBF,F
18E6:  RLCF   xC0,F
18E8:  RLCF   xC1,F
18EA:  DECF   00,F
18EC:  BTFSC  FD8.2
18EE:  BRA    19DE
18F0:  BRA    18DC
18F2:  BSF    xBD.7
18F4:  BRA    1946
18F6:  BCF    xBD.7
18F8:  MOVFF  B8,BC
18FC:  BTFSS  xB8.7
18FE:  BRA    1904
1900:  BSF    xC1.7
1902:  BRA    19D0
1904:  BCF    xC1.7
1906:  BRA    19D0
1908:  MOVFF  B8,C1
190C:  BSF    xC1.7
190E:  MOVFF  B9,C0
1912:  MOVFF  BA,BF
1916:  BTFSS  xBC.7
1918:  BRA    1922
191A:  BCF    xC1.7
191C:  BSF    xBD.2
191E:  BRA    19E8
1920:  BCF    xBD.2
1922:  CLRF   xBE
1924:  BCF    xBB.0
1926:  CLRF   FEA
1928:  MOVLW  B6
192A:  MOVWF  FE9
192C:  BRA    1A0E
192E:  BTFSC  xBC.7
1930:  BRA    196A
1932:  MOVFF  B4,BC
1936:  BTFSS  xBB.0
1938:  BRA    1946
193A:  RRCF   xC1,F
193C:  RRCF   xC0,F
193E:  RRCF   xBF,F
1940:  RRCF   xBE,F
1942:  INCF   00,F
1944:  BZ    19DE
1946:  BTFSS  xBE.7
1948:  BRA    1960
194A:  INCF   xBF,F
194C:  BNZ   1960
194E:  INCF   xC0,F
1950:  BNZ   1960
1952:  INCF   xC1,F
1954:  BNZ   1960
1956:  RRCF   xC1,F
1958:  RRCF   xC0,F
195A:  RRCF   xBF,F
195C:  INCF   00,F
195E:  BZ    19DE
1960:  BTFSC  xBD.6
1962:  BRA    1870
1964:  BTFSC  xBD.7
1966:  BRA    18F6
1968:  BRA    19A2
196A:  MOVLW  80
196C:  XORWF  xC1,F
196E:  BTFSS  xC1.7
1970:  BRA    197A
1972:  BRA    19E8
1974:  MOVFF  B8,BC
1978:  BRA    198E
197A:  MOVFF  B4,BC
197E:  MOVF   xC1,F
1980:  BNZ   198E
1982:  MOVF   xC0,F
1984:  BNZ   198E
1986:  MOVF   xBF,F
1988:  BNZ   198E
198A:  CLRF   00
198C:  BRA    19D0
198E:  BTFSC  xC1.7
1990:  BRA    19A2
1992:  BCF    FD8.0
1994:  RLCF   xBE,F
1996:  RLCF   xBF,F
1998:  RLCF   xC0,F
199A:  RLCF   xC1,F
199C:  DECFSZ 00,F
199E:  BRA    198E
19A0:  BRA    19DE
19A2:  BTFSS  xBC.7
19A4:  BRA    19AA
19A6:  BSF    xC1.7
19A8:  BRA    19D0
19AA:  BCF    xC1.7
19AC:  BRA    19D0
19AE:  MOVFF  B7,00
19B2:  MOVFF  B8,C1
19B6:  MOVFF  B9,C0
19BA:  MOVFF  BA,BF
19BE:  BRA    19D0
19C0:  MOVFF  B3,00
19C4:  MOVFF  B4,C1
19C8:  MOVFF  B5,C0
19CC:  MOVFF  B6,BF
19D0:  MOVFF  C1,01
19D4:  MOVFF  C0,02
19D8:  MOVFF  BF,03
19DC:  BRA    1A46
19DE:  CLRF   00
19E0:  CLRF   01
19E2:  CLRF   02
19E4:  CLRF   03
19E6:  BRA    1A46
19E8:  CLRF   xBE
19EA:  COMF   xBF,F
19EC:  COMF   xC0,F
19EE:  COMF   xC1,F
19F0:  COMF   xBE,F
19F2:  INCF   xBE,F
19F4:  BNZ   1A00
19F6:  INCF   xBF,F
19F8:  BNZ   1A00
19FA:  INCF   xC0,F
19FC:  BNZ   1A00
19FE:  INCF   xC1,F
1A00:  BTFSC  xBD.0
1A02:  BRA    182E
1A04:  BTFSC  xBD.1
1A06:  BRA    18B4
1A08:  BTFSC  xBD.2
1A0A:  BRA    1920
1A0C:  BRA    1974
1A0E:  MOVF   FEF,W
1A10:  ADDWF  xBF,F
1A12:  BNC   1A1E
1A14:  INCF   xC0,F
1A16:  BNZ   1A1E
1A18:  INCF   xC1,F
1A1A:  BTFSC  FD8.2
1A1C:  BSF    xBB.0
1A1E:  MOVF   FED,F
1A20:  MOVF   FEF,W
1A22:  ADDWF  xC0,F
1A24:  BNC   1A2C
1A26:  INCF   xC1,F
1A28:  BTFSC  FD8.2
1A2A:  BSF    xBB.0
1A2C:  MOVF   FED,F
1A2E:  MOVF   FEF,W
1A30:  BTFSC  FEF.7
1A32:  BRA    1A36
1A34:  XORLW  80
1A36:  ADDWF  xC1,F
1A38:  BTFSC  FD8.0
1A3A:  BSF    xBB.0
1A3C:  BTFSC  xBD.4
1A3E:  BRA    183C
1A40:  BTFSC  xBD.5
1A42:  BRA    18C2
1A44:  BRA    192E
1A46:  RETURN 0
1A48:  MOVLW  8E
1A4A:  MOVWF  00
1A4C:  MOVFF  B4,01
1A50:  MOVFF  B3,02
1A54:  CLRF   03
1A56:  BTFSS  xB4.7
1A58:  BRA    1A64
1A5A:  COMF   01,F
1A5C:  COMF   02,F
1A5E:  INCF   02,F
1A60:  BNZ   1A64
1A62:  INCF   01,F
1A64:  MOVF   01,F
1A66:  BNZ   1A7A
1A68:  MOVFF  02,01
1A6C:  CLRF   02
1A6E:  MOVLW  08
1A70:  SUBWF  00,F
1A72:  MOVF   01,F
1A74:  BNZ   1A7A
1A76:  CLRF   00
1A78:  BRA    1A8E
1A7A:  BCF    FD8.0
1A7C:  BTFSC  01.7
1A7E:  BRA    1A88
1A80:  RLCF   02,F
1A82:  RLCF   01,F
1A84:  DECF   00,F
1A86:  BRA    1A7A
1A88:  BTFSC  xB4.7
1A8A:  BRA    1A8E
1A8C:  BCF    01.7
1A8E:  RETURN 0
1A90:  MOVLW  8E
1A92:  MOVWF  00
1A94:  MOVFF  B4,01
1A98:  MOVFF  B3,02
1A9C:  CLRF   03
1A9E:  MOVF   01,F
1AA0:  BNZ   1AB4
1AA2:  MOVFF  02,01
1AA6:  CLRF   02
1AA8:  MOVLW  08
1AAA:  SUBWF  00,F
1AAC:  MOVF   01,F
1AAE:  BNZ   1AB4
1AB0:  CLRF   00
1AB2:  BRA    1AC4
1AB4:  BCF    FD8.0
1AB6:  BTFSC  01.7
1AB8:  BRA    1AC2
1ABA:  RLCF   02,F
1ABC:  RLCF   01,F
1ABE:  DECF   00,F
1AC0:  BRA    1AB4
1AC2:  BCF    01.7
1AC4:  GOTO   1F70 (RETURN)
1AC8:  MOVFF  B0,B7
1ACC:  MOVF   xB4,W
1ACE:  XORWF  xB7,F
1AD0:  BTFSS  xB7.7
1AD2:  BRA    1ADE
1AD4:  BCF    FD8.2
1AD6:  BCF    FD8.0
1AD8:  BTFSC  xB0.7
1ADA:  BSF    FD8.0
1ADC:  BRA    1B3C
1ADE:  MOVFF  B0,B7
1AE2:  MOVFF  B3,B8
1AE6:  MOVF   xAF,W
1AE8:  SUBWF  xB8,F
1AEA:  BZ    1AF8
1AEC:  BTFSS  xB7.7
1AEE:  BRA    1B3C
1AF0:  MOVF   FD8,W
1AF2:  XORLW  01
1AF4:  MOVWF  FD8
1AF6:  BRA    1B3C
1AF8:  MOVFF  B4,B8
1AFC:  MOVF   xB0,W
1AFE:  SUBWF  xB8,F
1B00:  BZ    1B0E
1B02:  BTFSS  xB7.7
1B04:  BRA    1B3C
1B06:  MOVF   FD8,W
1B08:  XORLW  01
1B0A:  MOVWF  FD8
1B0C:  BRA    1B3C
1B0E:  MOVFF  B5,B8
1B12:  MOVF   xB1,W
1B14:  SUBWF  xB8,F
1B16:  BZ    1B24
1B18:  BTFSS  xB7.7
1B1A:  BRA    1B3C
1B1C:  MOVF   FD8,W
1B1E:  XORLW  01
1B20:  MOVWF  FD8
1B22:  BRA    1B3C
1B24:  MOVFF  B6,B8
1B28:  MOVF   xB2,W
1B2A:  SUBWF  xB8,F
1B2C:  BZ    1B3A
1B2E:  BTFSS  xB7.7
1B30:  BRA    1B3C
1B32:  MOVF   FD8,W
1B34:  XORLW  01
1B36:  MOVWF  FD8
1B38:  BRA    1B3C
1B3A:  BCF    FD8.0
1B3C:  GOTO   1FBE (RETURN)
*
24AA:  MOVF   xAA,W
24AC:  CLRF   01
24AE:  SUBWF  xA9,W
24B0:  BC    24B8
24B2:  MOVFF  A9,00
24B6:  BRA    24D0
24B8:  CLRF   00
24BA:  MOVLW  08
24BC:  MOVWF  xAB
24BE:  RLCF   xA9,F
24C0:  RLCF   00,F
24C2:  MOVF   xAA,W
24C4:  SUBWF  00,W
24C6:  BTFSC  FD8.0
24C8:  MOVWF  00
24CA:  RLCF   01,F
24CC:  DECFSZ xAB,F
24CE:  BRA    24BE
24D0:  RETURN 0
24D2:  MOVF   01,W
24D4:  MOVFF  A7,A9
24D8:  MOVLW  64
24DA:  MOVWF  xAA
24DC:  RCALL  24AA
24DE:  MOVFF  00,A7
24E2:  MOVF   01,W
24E4:  MOVLW  30
24E6:  BNZ   24F6
24E8:  BTFSS  xA8.1
24EA:  BRA    2506
24EC:  BTFSC  xA8.3
24EE:  BRA    2506
24F0:  BTFSC  xA8.4
24F2:  MOVLW  20
24F4:  BRA    24FC
24F6:  BCF    xA8.3
24F8:  BCF    xA8.4
24FA:  BSF    xA8.0
24FC:  ADDWF  01,F
24FE:  MOVF   01,W
2500:  BTFSS  F9E.4
2502:  BRA    2500
2504:  MOVWF  FAD
2506:  MOVFF  A7,A9
250A:  MOVLW  0A
250C:  MOVWF  xAA
250E:  RCALL  24AA
2510:  MOVFF  00,A7
2514:  MOVF   01,W
2516:  MOVLW  30
2518:  BNZ   2526
251A:  BTFSC  xA8.3
251C:  BRA    2530
251E:  BTFSS  xA8.0
2520:  BRA    2530
2522:  BTFSC  xA8.4
2524:  MOVLW  20
2526:  ADDWF  01,F
2528:  MOVF   01,W
252A:  BTFSS  F9E.4
252C:  BRA    252A
252E:  MOVWF  FAD
2530:  MOVLW  30
2532:  ADDWF  xA7,F
2534:  MOVF   xA7,W
2536:  BTFSS  F9E.4
2538:  BRA    2536
253A:  MOVWF  FAD
253C:  RETURN 0
253E:  MOVF   FE9,W
2540:  MOVWF  xA9
2542:  MOVLW  3B
2544:  MOVWF  xB0
2546:  MOVLW  9A
2548:  MOVWF  xAF
254A:  MOVLW  CA
254C:  MOVWF  xAE
254E:  CLRF   xAD
2550:  MOVLW  0A
2552:  MOVWF  xAB
2554:  BSF    FD8.1
2556:  CLRF   FEA
2558:  MOVLW  A5
255A:  MOVWF  FE9
255C:  MOVFF  A8,B4
2560:  MOVFF  A7,B3
2564:  MOVFF  A6,B2
2568:  MOVFF  A5,B1
256C:  MOVFF  B0,B8
2570:  MOVFF  AF,B7
2574:  MOVFF  AE,B6
2578:  MOVFF  AD,B5
257C:  CALL   0FD4
2580:  MOVF   01,W
2582:  MOVF   00,F
2584:  BNZ   25A4
2586:  MOVF   xAB,W
2588:  XORLW  01
258A:  BZ    25A4
258C:  MOVF   xA9,W
258E:  BZ    25A6
2590:  ANDLW  0F
2592:  SUBWF  xAB,W
2594:  BZ    2598
2596:  BC    25B2
2598:  BTFSC  xA9.7
259A:  BRA    25B2
259C:  BTFSC  xA9.6
259E:  BRA    25A6
25A0:  MOVLW  20
25A2:  BRA    25A8
25A4:  CLRF   xA9
25A6:  MOVLW  30
25A8:  ADDWF  00,F
25AA:  MOVF   00,W
25AC:  BTFSS  F9E.4
25AE:  BRA    25AC
25B0:  MOVWF  FAD
25B2:  BCF    FD8.1
25B4:  MOVFF  B0,B4
25B8:  MOVFF  AF,B3
25BC:  MOVFF  AE,B2
25C0:  MOVFF  AD,B1
25C4:  CLRF   xB8
25C6:  CLRF   xB7
25C8:  CLRF   xB6
25CA:  MOVLW  0A
25CC:  MOVWF  xB5
25CE:  CALL   0FD4
25D2:  MOVFF  03,B0
25D6:  MOVFF  02,AF
25DA:  MOVFF  01,AE
25DE:  MOVFF  00,AD
25E2:  DECFSZ xAB,F
25E4:  BRA    2554
25E6:  RETURN 0
25E8:  BTFSC  xA5.7
25EA:  BRA    260C
25EC:  MOVLW  0F
25EE:  MOVWF  00
25F0:  SWAPF  xA4,W
25F2:  ANDWF  00,F
25F4:  MOVLW  0A
25F6:  SUBWF  00,W
25F8:  BC    2600
25FA:  MOVLW  30
25FC:  ADDWF  00,F
25FE:  BRA    2604
2600:  MOVF   xA5,W
2602:  ADDWF  00,F
2604:  MOVF   00,W
2606:  BTFSS  F9E.4
2608:  BRA    2606
260A:  MOVWF  FAD
260C:  MOVLW  0F
260E:  ANDWF  xA4,F
2610:  MOVLW  0A
2612:  SUBWF  xA4,W
2614:  BC    261A
2616:  MOVLW  30
2618:  BRA    261E
261A:  BCF    xA5.7
261C:  MOVF   xA5,W
261E:  ADDWF  xA4,F
2620:  MOVF   xA4,W
2622:  BTFSS  F9E.4
2624:  BRA    2622
2626:  MOVWF  FAD
2628:  RETURN 0
....................  
.................... #list 
....................  
.................... #fuses HS,NOPROTECT,NOLVP,NOWDT 
.................... #use delay(clock=20000000) 
*
05CA:  CLRF   FEA
05CC:  MOVLW  A4
05CE:  MOVWF  FE9
05D0:  MOVF   FEF,W
05D2:  BZ    05EE
05D4:  MOVLW  06
05D6:  MOVWF  01
05D8:  CLRF   00
05DA:  DECFSZ 00,F
05DC:  BRA    05DA
05DE:  DECFSZ 01,F
05E0:  BRA    05D8
05E2:  MOVLW  7B
05E4:  MOVWF  00
05E6:  DECFSZ 00,F
05E8:  BRA    05E6
05EA:  DECFSZ FEF,F
05EC:  BRA    05D4
05EE:  RETURN 0
.................... #use rs232(baud=38400, xmit=PIN_C6, rcv=PIN_C7) 
.................... #include <can-18xxx8.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.c                             //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18xxx8 CAN peripheral           //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specified message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transceiver to connect these pins to CANH and CANL bus lines.    //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ////  Mar 30 09 - added CANTX2 code for PIC18F6585/8585/6680/8680    //// 
.................... ////                                                                 //// 
.................... ////  May 18 10 - changed variable types to unsigned incase compiled //// 
.................... ////              with #device ANSI, which makes variables signed    //// 
.................... ////                                                                 //// 
.................... ////  Apr 20 11 - updated for new PIC18FxxK80 chips                  //// 
.................... ////                                                                 //// 
.................... ////  Jan 10 13 - updated can_init() function to setup correct tris  //// 
.................... ////              register for PIC being used.                       //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <can-18xxx8.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.h                             //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18xxx8.c)                                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __CCS_CAN18xxx8_LIB_DEFINES__ 
.................... #define __CCS_CAN18xxx8_LIB_DEFINES__ 
....................  
.................... #ifndef CAN_DO_DEBUG 
....................  #define CAN_DO_DEBUG FALSE 
.................... #endif 
....................  
.................... #IFNDEF CAN_USE_EXTENDED_ID 
....................   #define CAN_USE_EXTENDED_ID         TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_PRESCALAR 
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #ENDIF 
....................  
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS 
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_SAM 
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1 
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PROPAGATION_TIME 
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_WAKE_FILTER 
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2 
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER 
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_DRIVE_HIGH 
....................  #define CAN_ENABLE_DRIVE_HIGH 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CAN_CAPTURE 
....................  #define CAN_ENABLE_CAN_CAPTURE 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CANTX2           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_ENABLE_CANTX2 0      // 0 CANTX2 disabled, 1 CANTX2 enabled 
.................... #endif 
....................  
.................... #ifndef CAN_CANTX2_SOURCE           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_CANTX2_SOURCE 0      // 0 source is invert of CANTX1, 1 source is CAN Clock 
.................... #endif 
....................  
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_DISABLE=1, CAN_OP_NORMAL=0}; 
.................... enum CAN_WIN_ADDRESS {CAN_WIN_RX0=0, CAN_WIN_RX1=5, CAN_WIN_TX0=4, CAN_WIN_TX1=3, CAN_WIN_TX2=2}; 
....................  
.................... //can control 
.................... struct { 
....................    int1 void0; //0 
....................    CAN_WIN_ADDRESS win:3;   //1:3 //window address bits 
....................    int1 abat;   //4 //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3;   //5:7   //request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = getenv("SFR:CANCON")   //0xF6F 
....................  
....................  
.................... enum CAN_INT_CODE {CAN_INT_WAKEUP=7, CAN_INT_RX0=6, CAN_INT_RX1=5, CAN_INT_TX0=4, CAN_INT_TX1=3, CAN_INT_TX2=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
....................    int1 void0;   //0 
....................    CAN_INT_CODE icode:3;   //1:3   //interrupt code 
....................    int1 void4;   //4 
....................    CAN_OP_MODE opmode:3;   //5:7   //operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = getenv("SFR:CANSTAT")   //0xF6E 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
....................    int1 ewarn;      //0 //error warning 
....................    int1 rxwarn;      //1 //receiver warning 
....................    int1 txwarn;      //2 //transmitter warning 
....................    int1 rxbp;   //3 //receiver bus passive 
....................    int1 txbp;   //4 //transmitter bus passive bit 
....................    int1 txbo;   //5   //transmitter bus off 
....................    int1 rx1ovfl;   //6   //receive buffer 1 overflow 
....................    int1 rx0ovfl;   //7   //receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT= getenv("SFR:COMSTAT") //0xF74 
....................  
.................... //baud rate control register 1 
.................... struct { 
....................    int brp:6;   //0:5   //baud rate prescalar 
....................    int sjw:2;   //6:7   //synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1 = getenv("SFR:BRGCON1")   //0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
....................    int prseg:3; //0:2 //propagation time select 
....................    int seg1ph:3; //3:5 //phase segment 1 
....................    int1 sam; //6 //sample of the can bus line 
....................    int1 seg2phts; //7 //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2 = getenv("SFR:BRGCON2")   //0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
....................    int seg2ph:3;   //0:2   //phase segment 2 time select 
....................    int void543:3;   //3:5 
....................    int1 wakfil;   //6 //selects can bus line filter for wake-up 
....................    int1 void7;   //7 
.................... } BRGCON3; 
.................... #byte BRGCON3 = getenv("SFR:BRGCON3")   //0xF72 
....................  
.................... //can i/o control register 
.................... struct { 
....................    int void3210:4;   //0:3 
....................    int1 cancap;   //4 //can message receive capture 
....................    int1 endrhi;   //5 //enable drive high 
....................    int1 tx2en;    //6   //CANTX2 Pin Enable bit       //added 3/30/09 for PIC18F6585/8585/6680/8680 
....................    int1 tx2src;   //7   //CANTX2 Pin Data Source bit  //added 3/30/09 for PIC18F6585/8585/6680/8680 
.................... } CIOCON; 
.................... #byte CIOCON = getenv("SFR:CIOCON")    //0xF73 
....................  
.................... //transmit buffer n control register 
.................... struct txbNcon_struct { 
....................    int  txpri:2;   //0:1   //transmit priority bits 
....................    int1 void2; //2 
....................    int1 txreq;   //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;   //4   //transmission error detected 
....................    int1 txlarb;   //5   //transmission lost arbitration status 
....................    int1 txabt;   //6   //transmission aborted status 
....................    int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte   TXB0CON = getenv("SFR:TXB0CON")      //0xF40 
.................... #byte   TXB1CON = getenv("SFR:TXB1CON")      //0xF30 
.................... #byte   TXB2CON = getenv("SFR:TXB2CON")      //0xF20 
.................... #byte TXBaCON =     0xF60             // txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH = getenv("SFR:TXB0SIDH")      // 
.................... #byte TXB0SIDL = getenv("SFR:TXB0SIDL")      // 
.................... #byte TXB1SIDH = getenv("SFR:TXB1SIDH")      // 
.................... #byte TXB1SIDL = getenv("SFR:TXB1SIDL")      // 
.................... #byte TXB2SIDH = getenv("SFR:TXB2SIDH")      // 
.................... #byte TXB2SIDL = getenv("SFR:TXB2SIDL")      // 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH = getenv("SFR:TXB0EIDH")      //0xF43 
.................... #byte TXB0EIDL = getenv("SFR:TXB0EIDL")      //0xF44 
.................... #byte TXB1EIDH = getenv("SFR:TXB1EIDH")      //0xF33 
.................... #byte TXB1EIDL = getenv("SFR:TXB1EIDL")      //0xF34 
.................... #byte TXB2EIDH = getenv("SFR:TXB2EIDH")      //0xF23 
.................... #byte TXB2EIDL = getenv("SFR:TXB2EIDL")      //0xF24 
....................  
.................... #define RX0MASK      getenv("SFR:RXM0EIDL")     //0xF1B    //rxm0eidl 
.................... #define RX1MASK      getenv("SFR:RXM1EIDL")     //0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   getenv("SFR:RXF0EIDL")     //0xF03    //rxf0eidl 
.................... #define RX0FILTER1   getenv("SFR:RXF1EIDL")     //0xF07    //rxf1eidl 
.................... #define RX1FILTER2   getenv("SFR:RXF2EIDL")     //0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   getenv("SFR:RXF3EIDL")     //0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   getenv("SFR:RXF4EIDL")     //0xF13    //rxf4eidl 
.................... #define RX1FILTER5   getenv("SFR:RXF5EIDL")     //0xF17    //rxf5eidl 
.................... #define RXB0ID       getenv("SFR:RXB0EIDL")     //0xF64    //rxb0eidl 
.................... #define RXB1ID       getenv("SFR:RXB1EIDL")     //0xF54    //rxb1eidl 
.................... #define TXB0ID       getenv("SFR:TXB0EIDL")     //0xF44    //txb0eidl 
.................... #define TXB1ID       getenv("SFR:TXB1EIDL")     //0xF34    //txb1eidl 
.................... #define TXB2ID       getenv("SFR:TXB2EIDL")     //0xF24    //tsb2eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0 = getenv("SFR:TXB0D0")       //0xF46 
.................... #byte TXB0D7 = getenv("SFR:TXB0D7")       //0xF4D 
.................... #byte TXB1D0 = getenv("SFR:TXB1D0")       //0xF36 
.................... #byte TXB1D7 = getenv("SFR:TXB1D7")       //0xF3D 
.................... #byte TXB2D0 = getenv("SFR:TXB2D0")       //0xF26 
.................... #byte TXB2D7 = getenv("SFR:TXB2D7")       //0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;   //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr; //6 //transmission frame remote transmission 
....................    int1 void7; //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC = getenv("SFR:TXB0DLC")     //0xF45 
.................... #byte TXB1DLC = getenv("SFR:TXB1DLC")     //0xF35 
.................... #byte TXB2DLC = getenv("SFR:TXB2DLC")     //0xF25 
.................... #byte TXBaDLC = 0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=getenv("SFR:TXERRCNT")     //0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct { 
....................    int1 filthit0;   //0 //filter hit 
....................    int1 jtoff;   //1 //jump table offset 
....................    int1 rxb0dben;   //2 //receive buffer 0 double buffer enable 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receiver buffer mode 
....................    int1 rxful;   //7 //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON = getenv("SFR:RXB0CON")     //0xF60 
....................  
.................... //receive buffer 1 control register 
.................... struct { 
....................    int filthit:3;   //0:2 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receive buffer mode 
....................    int1 rxful;   //7   //receive full 
.................... } RXB1CON; 
.................... #byte   RXB1CON = getenv("SFR:RXB1CON")     //0xF50 
....................  
....................  
.................... //receive buffer n standard identifier 
.................... #byte   RXB0SIDH = getenv("SFR:RXB0SIDH")    //0xF61 
.................... #byte   RXB0SIDL = getenv("SFR:RXB0SIDL")    //0xF62 
.................... #byte   RXB1SIDH = getenv("SFR:RXB1SIDH")    //0xF51 
.................... #byte   RXB1SIDL = getenv("SFR:RXB1SIDL")    //0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte   RXB0EIDH = getenv("SFR:RXB0EIDH")    //0xF63 
.................... #byte   RXB0EIDL = getenv("SFR:RXB0EIDL")    //0xF64 
.................... #byte   RXB1EIDH = getenv("SFR:RXB1EIDH")    //0xF53 
.................... #byte   RXB1EIDL = getenv("SFR:RXB1EIDL")    //0xF54 
....................  
.................... #byte TXRXBaEIDL=0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;   //extended id 
....................    int1 srr;   //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL=0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0; //4 //reserved 
....................    int1 rb1;   //5 //reserved 
....................    int1 rtr;   //6 //receiver remote transmission request bit 
....................    int1 void7;   //7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte   RXB0DLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... #byte   RXB1DLC = getenv("SFR:RXB1DLC")      //0xF55 
.................... #byte   RXBaDLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0 = getenv("SFR:RXB0D0")    //0xF66 
.................... #byte RXB0D7 = getenv("SFR:RXB0D7")    //0xF6D 
.................... #byte TXRXBaD0=0xF66 
.................... #byte TXRXBaD7=0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT = getenv("SFR:RXERRCNT")      //0xF75 
....................  
.................... //receive acceptance filter n standard identifier 
.................... #byte RXF0SIDH = getenv("SFR:RXF0SIDH")      //0xF00 
.................... #byte RXF0SIDL = getenv("SFR:RXF0SIDL")      //0xF01 
.................... #byte RXF1SIDH = getenv("SFR:RXF1SIDH")      //0xF04 
.................... #byte RXF1SIDL = getenv("SFR:RXF1SIDL")      //0xF05 
.................... #byte RXF2SIDH = getenv("SFR:RXF2SIDH")      //0xF08 
.................... #byte RXF2SIDL = getenv("SFR:RXF2SIDL")      //0xF09 
.................... #byte RXF3SIDH = getenv("SFR:RXF3SIDH")      //0xF0C 
.................... #byte RXF3SIDL = getenv("SFR:RXF3SIDL")      //0xF0D 
.................... #byte RXF4SIDH = getenv("SFR:RXF4SIDH")      //0xF10 
.................... #byte RXF4SIDL = getenv("SFR:RXF4SIDL")      //0xF11 
.................... #byte RXF5SIDH = getenv("SFR:RXF5SIDH")      //0xF14 
.................... #byte RXF5SIDL = getenv("SFR:RXF5SIDL")      //0xF15 
....................  
.................... //receive acceptance filter n extended identifier 
.................... #byte RXF0EIDH = getenv("SFR:RXF0EIDH")      //0xF02 
.................... #byte RXF0EIDL = getenv("SFR:RXF0EIDL")      //0xF03 
.................... #byte RXF1EIDH = getenv("SFR:RXF1EIDH")      //0xF06 
.................... #byte RXF1EIDL = getenv("SFR:RXF1EIDL")      //0xF07 
.................... #byte RXF2EIDH = getenv("SFR:RXF2EIDH")      //0xF0A 
.................... #byte RXF2EIDL = getenv("SFR:RXF2EIDL")      //0xF0B 
.................... #byte RXF3EIDH = getenv("SFR:RXF3EIDH")      //0xF0E 
.................... #byte RXF3EIDL = getenv("SFR:RXF3EIDL")      //0xF0F 
.................... #byte RXF4EIDH = getenv("SFR:RXF4EIDH")      //0xF12 
.................... #byte RXF4EIDL = getenv("SFR:RXF4EIDL")      //0xF13 
.................... #byte RXF5EIDH = getenv("SFR:RXF5EIDH")      //0xF16 
.................... #byte RXF5EIDL = getenv("SFR:RXF5EIDL")      //0xF17 
....................  
.................... //receive acceptance mask n standard identifier mask 
.................... #byte RXM0SIDH = getenv("SFR:RXM0SIDH")      //0xF18 
.................... #byte RXM0SIDL = getenv("SFR:RXM0SIDL")      //0xF19 
.................... #byte RXM1SIDH = getenv("SFR:RXM1SIDH")      //0xF1C 
.................... #byte RXM1SIDL = getenv("SFR:RXM1SIDL")      //0xF1D 
....................  
.................... //receive acceptance mask n extended identifier mask 
.................... #byte RXM0EIDH = getenv("SFR:RXM0EIDH")      //0xF1A 
.................... #byte RXM0EIDL = getenv("SFR:RXM0EIDL")      //0xF1B 
.................... #byte RXM1EIDH = getenv("SFR:RXM1EIDH")      //0xF1E 
.................... #byte RXM1EIDL = getenv("SFR:RXM1EIDL")      //0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = getenv("BIT:IRXIF")     //0xFA4.7 
.................... #bit CAN_INT_WAKIF = getenv("BIT:WAKIF")     //0xFA4.6 
.................... #bit CAN_INT_ERRIF = getenv("BIT:ERRIF")     //0xFA4.5 
.................... #bit CAN_INT_TXB2IF = getenv("BIT:TXB2IF")   // 0xFA4.4 
.................... #bit CAN_INT_TXB1IF = getenv("BIT:TXB1IF")   // 0xFA4.3 
.................... #bit CAN_INT_TXB0IF = getenv("BIT:TXB0IF")   // 0xFA4.2 
.................... #bit CAN_INT_RXB1IF = getenv("BIT:RXB1IF")   // 0xFA4.1 
.................... #bit CAN_INT_RXB0IF = getenv("BIT:RXB0IF")   // 0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_id(unsigned int* addr, unsigned int32 id, int1 ext); 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext); 
.................... int1  can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat); 
....................  
.................... #endif 
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
....................  
.................... //macros 
.................... #define can_kbhit()                 (RXB0CON.rxful || RXB1CON.rxful) 
.................... #define can_tbe()                   (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
03C0:  MOVLW  04
03C2:  MOVWF  xA3
03C4:  RCALL  023E
....................    can_set_baud(); 
03C6:  BRA    0260
....................  
....................    RXB0CON=0; 
03C8:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
03CA:  MOVLW  9F
03CC:  ANDWF  F60,W
03CE:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
03D0:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
03D2:  MOVFF  F60,F50
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
03D6:  BCF    F73.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
03D8:  BCF    F73.4
....................    CIOCON.tx2src=CAN_CANTX2_SOURCE;       //added 3/30/09 for PIC18F6585/8585/6680/8680 
03DA:  BCF    F73.7
....................    CIOCON.tx2en=CAN_ENABLE_CANTX2;        //added 3/30/09 for PIC18F6585/8585/6680/8680 
03DC:  BCF    F73.6
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
03DE:  MOVLW  0F
03E0:  MOVWF  xB4
03E2:  MOVLW  1B
03E4:  MOVWF  xB3
03E6:  CLRF   xB8
03E8:  CLRF   xB7
03EA:  CLRF   xB6
03EC:  CLRF   xB5
03EE:  MOVLW  01
03F0:  MOVWF  xB9
03F2:  RCALL  0290
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
03F4:  MOVLW  0F
03F6:  MOVWF  xB4
03F8:  MOVLW  03
03FA:  MOVWF  xB3
03FC:  CLRF   xB8
03FE:  CLRF   xB7
0400:  CLRF   xB6
0402:  CLRF   xB5
0404:  MOVLW  01
0406:  MOVWF  xB9
0408:  RCALL  0290
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
040A:  MOVLW  0F
040C:  MOVWF  xB4
040E:  MOVLW  07
0410:  MOVWF  xB3
0412:  CLRF   xB8
0414:  CLRF   xB7
0416:  CLRF   xB6
0418:  CLRF   xB5
041A:  MOVLW  01
041C:  MOVWF  xB9
041E:  RCALL  0290
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
0420:  MOVLW  0F
0422:  MOVWF  xB4
0424:  MOVLW  1F
0426:  MOVWF  xB3
0428:  CLRF   xB8
042A:  CLRF   xB7
042C:  CLRF   xB6
042E:  CLRF   xB5
0430:  MOVLW  01
0432:  MOVWF  xB9
0434:  RCALL  0290
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
0436:  MOVLW  0F
0438:  MOVWF  xB4
043A:  MOVLW  0B
043C:  MOVWF  xB3
043E:  CLRF   xB8
0440:  CLRF   xB7
0442:  CLRF   xB6
0444:  CLRF   xB5
0446:  MOVLW  01
0448:  MOVWF  xB9
044A:  RCALL  0290
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
044C:  MOVLW  0F
044E:  MOVWF  xB4
0450:  MOVWF  xB3
0452:  CLRF   xB8
0454:  CLRF   xB7
0456:  CLRF   xB6
0458:  CLRF   xB5
045A:  MOVLW  01
045C:  MOVWF  xB9
045E:  RCALL  0290
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
0460:  MOVLW  0F
0462:  MOVWF  xB4
0464:  MOVLW  13
0466:  MOVWF  xB3
0468:  CLRF   xB8
046A:  CLRF   xB7
046C:  CLRF   xB6
046E:  CLRF   xB5
0470:  MOVLW  01
0472:  MOVWF  xB9
0474:  RCALL  0290
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
0476:  MOVLW  0F
0478:  MOVWF  xB4
047A:  MOVLW  17
047C:  MOVWF  xB3
047E:  CLRF   xB8
0480:  CLRF   xB7
0482:  CLRF   xB6
0484:  CLRF   xB5
0486:  MOVLW  01
0488:  MOVWF  xB9
048A:  RCALL  0290
....................  
....................   #if (getenv("DEVICE") == "PIC18F6585") || (getenv("DEVICE") == "PIC18LF6585") || \ 
....................       (getenv("DEVICE") == "PIC18F6680") || (getenv("DEVICE") == "PIC18LF6680") || \ 
....................       (getenv("DEVICE") == "PIC18F8585") || (getenv("DEVICE") == "PIC18LF8585") || \ 
....................       (getenv("DEVICE") == "PIC18F8680") || (getenv("DEVICE") == "PIC18LF8680") || \ 
....................       (getenv("DEVICE") == "PIC18C658") || (getenv("DEVICE") == "PIC18C858") 
....................    set_tris_g((*getenv("SFR:TRISG") & 0xFE) | 0x04);  //G2 in, G0 out 
....................    if(CAN_ENABLE_CANTX2) 
....................     bit_clear(*getenv("SFR:TRISG"), 1);  //G1 out 
....................   #elif getenv("FUSE_SET:CANE") 
....................    set_tris_e((*getenv("SFR:TRISE") & 0xDF) | 0x10);  //E4 in, E5 out 
....................   #elif getenv("FUSE_SET:CANC") 
....................    set_tris_c((*getenv("SFR:TRISC") & 0xBF) | 0x80);  //C7 in, C6 out 
....................   #else 
....................    set_tris_b((*getenv("SFR:TRISB") & 0xFB) | 0x08);  //B3 in, B2 out 
048C:  MOVF   F93,W
048E:  ANDLW  FB
0490:  IORLW  08
0492:  MOVWF  F93
....................   #endif 
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
0494:  CLRF   xA3
0496:  RCALL  023E
0498:  GOTO   2800 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
*
0260:  MOVLW  C0
0262:  ANDWF  F70,W
0264:  IORLW  04
0266:  MOVWF  F70
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
0268:  MOVLW  3F
026A:  ANDWF  F70,W
026C:  MOVWF  F70
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
026E:  MOVLW  F8
0270:  ANDWF  F71,W
0272:  IORLW  02
0274:  MOVWF  F71
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
0276:  MOVLW  C7
0278:  ANDWF  F71,W
027A:  IORLW  28
027C:  MOVWF  F71
....................    BRGCON2.sam=CAN_BRG_SAM; 
027E:  BCF    F71.6
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
0280:  BSF    F71.7
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
0282:  MOVLW  F8
0284:  ANDWF  F72,W
0286:  IORLW  05
0288:  MOVWF  F72
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
028A:  BCF    F72.6
028C:  GOTO   03C8 (RETURN)
.................... } 
....................  
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
023E:  SWAPF  xA3,W
0240:  ANDLW  70
0242:  MOVWF  00
0244:  BCF    FD8.0
0246:  RLCF   00,F
0248:  MOVLW  1F
024A:  ANDWF  F6F,W
024C:  IORWF  00,W
024E:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
0250:  MOVFF  F6E,00
0254:  SWAPF  00,F
0256:  RRCF   00,W
0258:  ANDLW  07
025A:  SUBWF  xA3,W
025C:  BNZ   0250
025E:  RETURN 0
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Parameters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(unsigned int* addr, unsigned int32 id, int1 ext) { 
....................    int *ptr; 
....................  
....................    ptr=addr; 
*
0290:  MOVFF  B4,BB
0294:  MOVFF  B3,BA
....................  
....................    if (ext) {  //extended 
0298:  MOVF   xB9,F
029A:  BZ    0340
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
029C:  MOVFF  BA,FE9
02A0:  MOVFF  BB,FEA
02A4:  MOVFF  B5,FEF
....................  
....................       //eidh 
....................       ptr--; 
02A8:  MOVF   xBA,W
02AA:  BTFSC  FD8.2
02AC:  DECF   xBB,F
02AE:  DECF   xBA,F
....................       *ptr=make8(id,1); //8:15 
02B0:  MOVFF  BA,FE9
02B4:  MOVFF  BB,FEA
02B8:  MOVFF  B6,FEF
....................  
....................       //sidl 
....................       ptr--; 
02BC:  MOVF   xBA,W
02BE:  BTFSC  FD8.2
02C0:  DECF   xBB,F
02C2:  DECF   xBA,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
02C4:  MOVFF  BA,FE9
02C8:  MOVFF  BB,FEA
02CC:  MOVF   xB7,W
02CE:  ANDLW  03
02D0:  MOVWF  FEF
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
02D2:  MOVFF  BA,FE9
02D6:  MOVFF  BB,FEA
02DA:  MOVFF  B7,00
02DE:  RLCF   00,F
02E0:  RLCF   00,F
02E2:  RLCF   00,F
02E4:  MOVLW  F8
02E6:  ANDWF  00,F
02E8:  MOVF   00,W
02EA:  ANDLW  E0
02EC:  IORWF  FEF,W
02EE:  MOVWF  FEF
....................       *ptr|=0x08; 
02F0:  MOVFF  BA,FE9
02F4:  MOVFF  BB,FEA
02F8:  MOVF   FEF,W
02FA:  IORLW  08
02FC:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       ptr--; 
02FE:  MOVF   xBA,W
0300:  BTFSC  FD8.2
0302:  DECF   xBB,F
0304:  DECF   xBA,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
0306:  MOVFF  BA,FE9
030A:  MOVFF  BB,FEA
030E:  MOVFF  B7,00
0312:  SWAPF  00,F
0314:  RRCF   00,F
0316:  MOVLW  07
0318:  ANDWF  00,F
031A:  MOVF   00,W
031C:  ANDLW  07
031E:  MOVWF  FEF
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
0320:  MOVFF  BA,FE9
0324:  MOVFF  BB,FEA
0328:  MOVFF  B8,00
032C:  RLCF   00,F
032E:  RLCF   00,F
0330:  RLCF   00,F
0332:  MOVLW  F8
0334:  ANDWF  00,F
0336:  MOVF   00,W
0338:  ANDLW  F8
033A:  IORWF  FEF,W
033C:  MOVWF  FEF
....................    } 
033E:  BRA    03BE
....................    else {   //standard 
....................       //eidl 
....................       *ptr=0; 
0340:  MOVFF  BA,FE9
0344:  MOVFF  BB,FEA
0348:  CLRF   FEF
....................  
....................       //eidh 
....................       ptr--; 
034A:  MOVF   xBA,W
034C:  BTFSC  FD8.2
034E:  DECF   xBB,F
0350:  DECF   xBA,F
....................       *ptr=0; 
0352:  MOVFF  BA,FE9
0356:  MOVFF  BB,FEA
035A:  CLRF   FEF
....................  
....................       //sidl 
....................       ptr--; 
035C:  MOVF   xBA,W
035E:  BTFSC  FD8.2
0360:  DECF   xBB,F
0362:  DECF   xBA,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
0364:  MOVFF  BA,FE9
0368:  MOVFF  BB,FEA
036C:  MOVFF  B5,00
0370:  SWAPF  00,F
0372:  RLCF   00,F
0374:  MOVLW  E0
0376:  ANDWF  00,F
0378:  MOVF   00,W
037A:  ANDLW  E0
037C:  MOVWF  FEF
....................  
....................       //sidh 
....................       ptr--; 
037E:  MOVF   xBA,W
0380:  BTFSC  FD8.2
0382:  DECF   xBB,F
0384:  DECF   xBA,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
0386:  MOVFF  BA,FE9
038A:  MOVFF  BB,FEA
038E:  MOVFF  B5,00
0392:  RRCF   00,F
0394:  RRCF   00,F
0396:  RRCF   00,F
0398:  MOVLW  1F
039A:  ANDWF  00,F
039C:  MOVF   00,W
039E:  ANDLW  1F
03A0:  MOVWF  FEF
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
03A2:  MOVFF  BA,FE9
03A6:  MOVFF  BB,FEA
03AA:  MOVFF  B6,00
03AE:  SWAPF  00,F
03B0:  RLCF   00,F
03B2:  MOVLW  E0
03B4:  ANDWF  00,F
03B6:  MOVF   00,W
03B8:  ANDLW  E0
03BA:  IORWF  FEF,W
03BC:  MOVWF  FEF
....................    } 
03BE:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Parameters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext) { 
....................    unsigned int32 ret; 
....................    unsigned int * ptr; 
....................  
....................    ret=0; 
*
22C8:  CLRF   xB5
22CA:  CLRF   xB4
22CC:  CLRF   xB3
22CE:  CLRF   xB2
....................    ptr=addr; 
22D0:  MOVFF  B0,B7
22D4:  MOVFF  AF,B6
....................  
....................    if (ext) { 
22D8:  MOVF   xB1,F
22DA:  BTFSC  FD8.2
22DC:  BRA    23F0
....................       ret=*ptr;  //eidl 
22DE:  MOVFF  B6,FE9
22E2:  MOVFF  B7,FEA
22E6:  CLRF   xB5
22E8:  CLRF   xB4
22EA:  CLRF   xB3
22EC:  MOVFF  FEF,B2
....................  
....................       ptr--;     //eidh 
22F0:  MOVF   xB6,W
22F2:  BTFSC  FD8.2
22F4:  DECF   xB7,F
22F6:  DECF   xB6,F
....................       ret|=((unsigned int32)*ptr << 8); 
22F8:  MOVFF  B6,FE9
22FC:  MOVFF  B7,FEA
2300:  MOVF   FEF,W
2302:  CLRF   xBA
2304:  CLRF   xB9
2306:  MOVWF  xB8
2308:  CLRF   00
230A:  MOVF   00,W
230C:  IORWF  xB2,F
230E:  MOVF   xB8,W
2310:  IORWF  xB3,F
2312:  MOVF   xB9,W
2314:  IORWF  xB4,F
2316:  MOVF   xBA,W
2318:  IORWF  xB5,F
....................  
....................       ptr--;     //sidl 
231A:  MOVF   xB6,W
231C:  BTFSC  FD8.2
231E:  DECF   xB7,F
2320:  DECF   xB6,F
....................       ret|=((unsigned int32)*ptr & 0x03) << 16; 
2322:  MOVFF  B6,FE9
2326:  MOVFF  B7,FEA
232A:  MOVF   FEF,W
232C:  CLRF   xBB
232E:  CLRF   xBA
2330:  CLRF   xB9
2332:  MOVWF  xB8
2334:  MOVLW  03
2336:  ANDWF  xB8,F
2338:  CLRF   xB9
233A:  CLRF   xBA
233C:  CLRF   xBB
233E:  CLRF   00
2340:  CLRF   01
2342:  MOVF   00,W
2344:  IORWF  xB2,F
2346:  MOVF   01,W
2348:  IORWF  xB3,F
234A:  MOVF   xB8,W
234C:  IORWF  xB4,F
234E:  MOVF   xB9,W
2350:  IORWF  xB5,F
....................       ret|=((unsigned int32)*ptr & 0xE0) << 13; 
2352:  MOVFF  B6,FE9
2356:  MOVFF  B7,FEA
235A:  MOVF   FEF,W
235C:  CLRF   xBB
235E:  CLRF   xBA
2360:  CLRF   xB9
2362:  MOVWF  xB8
2364:  MOVLW  E0
2366:  ANDWF  xB8,F
2368:  CLRF   xB9
236A:  CLRF   xBA
236C:  CLRF   xBB
236E:  CLRF   00
2370:  RLCF   xB8,W
2372:  MOVWF  01
2374:  RLCF   xB9,W
2376:  MOVWF  02
2378:  RLCF   xBA,W
237A:  MOVWF  03
237C:  RLCF   01,F
237E:  RLCF   02,F
2380:  RLCF   03,F
2382:  RLCF   01,F
2384:  RLCF   02,F
2386:  RLCF   03,F
2388:  RLCF   01,F
238A:  RLCF   02,F
238C:  RLCF   03,F
238E:  RLCF   01,F
2390:  RLCF   02,F
2392:  RLCF   03,F
2394:  MOVLW  E0
2396:  ANDWF  01,F
2398:  MOVF   00,W
239A:  IORWF  xB2,F
239C:  MOVF   01,W
239E:  IORWF  xB3,F
23A0:  MOVF   02,W
23A2:  IORWF  xB4,F
23A4:  MOVF   03,W
23A6:  IORWF  xB5,F
....................  
....................       ptr--;     //sidh 
23A8:  MOVF   xB6,W
23AA:  BTFSC  FD8.2
23AC:  DECF   xB7,F
23AE:  DECF   xB6,F
....................       ret|=((unsigned int32)*ptr << 21); 
23B0:  MOVFF  B6,FE9
23B4:  MOVFF  B7,FEA
23B8:  MOVF   FEF,W
23BA:  CLRF   xB9
23BC:  MOVWF  xB8
23BE:  CLRF   00
23C0:  CLRF   01
23C2:  RLCF   xB8,W
23C4:  MOVWF  02
23C6:  RLCF   xB9,W
23C8:  MOVWF  03
23CA:  RLCF   02,F
23CC:  RLCF   03,F
23CE:  RLCF   02,F
23D0:  RLCF   03,F
23D2:  RLCF   02,F
23D4:  RLCF   03,F
23D6:  RLCF   02,F
23D8:  RLCF   03,F
23DA:  MOVLW  E0
23DC:  ANDWF  02,F
23DE:  MOVF   00,W
23E0:  IORWF  xB2,F
23E2:  MOVF   01,W
23E4:  IORWF  xB3,F
23E6:  MOVF   02,W
23E8:  IORWF  xB4,F
23EA:  MOVF   03,W
23EC:  IORWF  xB5,F
....................  
....................    } 
23EE:  BRA    2496
....................    else { 
....................       ptr-=2;    //sidl 
23F0:  MOVLW  02
23F2:  SUBWF  xB6,F
23F4:  MOVLW  00
23F6:  SUBWFB xB7,F
....................       ret=((unsigned int32)*ptr & 0xE0) >> 5; 
23F8:  MOVFF  B6,FE9
23FC:  MOVFF  B7,FEA
2400:  MOVF   FEF,W
2402:  CLRF   xBB
2404:  CLRF   xBA
2406:  CLRF   xB9
2408:  MOVWF  xB8
240A:  MOVLW  E0
240C:  ANDWF  xB8,F
240E:  CLRF   xB9
2410:  CLRF   xBA
2412:  CLRF   xBB
2414:  RRCF   xBB,W
2416:  MOVWF  xB5
2418:  RRCF   xBA,W
241A:  MOVWF  xB4
241C:  RRCF   xB9,W
241E:  MOVWF  xB3
2420:  RRCF   xB8,W
2422:  MOVWF  xB2
2424:  RRCF   xB5,F
2426:  RRCF   xB4,F
2428:  RRCF   xB3,F
242A:  RRCF   xB2,F
242C:  RRCF   xB5,F
242E:  RRCF   xB4,F
2430:  RRCF   xB3,F
2432:  RRCF   xB2,F
2434:  RRCF   xB5,F
2436:  RRCF   xB4,F
2438:  RRCF   xB3,F
243A:  RRCF   xB2,F
243C:  RRCF   xB5,F
243E:  RRCF   xB4,F
2440:  RRCF   xB3,F
2442:  RRCF   xB2,F
2444:  MOVLW  07
2446:  ANDWF  xB5,F
....................  
....................       ptr--;     //sidh 
2448:  MOVF   xB6,W
244A:  BTFSC  FD8.2
244C:  DECF   xB7,F
244E:  DECF   xB6,F
....................       ret|=((unsigned int32)*ptr << 3); 
2450:  MOVFF  B6,FE9
2454:  MOVFF  B7,FEA
2458:  MOVF   FEF,W
245A:  CLRF   xBB
245C:  CLRF   xBA
245E:  CLRF   xB9
2460:  MOVWF  xB8
2462:  RLCF   xB8,W
2464:  MOVWF  00
2466:  RLCF   xB9,W
2468:  MOVWF  01
246A:  RLCF   xBA,W
246C:  MOVWF  02
246E:  RLCF   xBB,W
2470:  MOVWF  03
2472:  RLCF   00,F
2474:  RLCF   01,F
2476:  RLCF   02,F
2478:  RLCF   03,F
247A:  RLCF   00,F
247C:  RLCF   01,F
247E:  RLCF   02,F
2480:  RLCF   03,F
2482:  MOVLW  F8
2484:  ANDWF  00,F
2486:  MOVF   00,W
2488:  IORWF  xB2,F
248A:  MOVF   01,W
248C:  IORWF  xB3,F
248E:  MOVF   02,W
2490:  IORWF  xB4,F
2492:  MOVF   03,W
2494:  IORWF  xB5,F
....................    } 
....................  
....................    return(ret); 
2496:  MOVFF  B2,00
249A:  MOVFF  B3,01
249E:  MOVFF  B4,02
24A2:  MOVFF  B5,03
24A6:  GOTO   2A36 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Parameters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr) { 
....................    unsigned int i; 
....................    unsigned int * txd0; 
....................    unsigned int port; 
....................  
....................    txd0=&TXRXBaD0; 
*
262A:  MOVLW  0F
262C:  MOVWF  xB1
262E:  MOVLW  66
2630:  MOVWF  xB0
....................  
....................     // find empty transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) { 
2632:  MOVLB  F
2634:  BTFSC  x40.3
2636:  BRA    2648
....................       CANCON.win=CAN_WIN_TX0; 
2638:  MOVLW  F1
263A:  ANDWF  F6F,W
263C:  IORLW  08
263E:  MOVWF  F6F
....................       port=0; 
2640:  MOVLB  0
2642:  CLRF   xB2
....................    } 
2644:  BRA    267C
2646:  MOVLB  F
....................    else if (!TXB1CON.txreq) { 
2648:  BTFSC  x30.3
264A:  BRA    265E
....................       CANCON.win=CAN_WIN_TX1; 
264C:  MOVLW  F1
264E:  ANDWF  F6F,W
2650:  IORLW  06
2652:  MOVWF  F6F
....................       port=1; 
2654:  MOVLW  01
2656:  MOVLB  0
2658:  MOVWF  xB2
....................    } 
265A:  BRA    267C
265C:  MOVLB  F
....................    else if (!TXB2CON.txreq) { 
265E:  BTFSC  x20.3
2660:  BRA    2674
....................       CANCON.win=CAN_WIN_TX2; 
2662:  MOVLW  F1
2664:  ANDWF  F6F,W
2666:  IORLW  04
2668:  MOVWF  F6F
....................       port=2; 
266A:  MOVLW  02
266C:  MOVLB  0
266E:  MOVWF  xB2
....................    } 
2670:  BRA    267C
2672:  MOVLB  F
....................    else { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
2674:  MOVLW  00
2676:  MOVWF  01
2678:  BRA    26F2
267A:  MOVLB  0
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
267C:  MOVF   xAC,W
267E:  ANDLW  03
2680:  MOVWF  00
2682:  MOVLW  FC
2684:  ANDWF  F60,W
2686:  IORWF  00,W
2688:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
268A:  MOVLW  0F
268C:  MOVWF  xB4
268E:  MOVLW  64
2690:  MOVWF  xB3
2692:  MOVFF  A8,B8
2696:  MOVFF  A7,B7
269A:  MOVFF  A6,B6
269E:  MOVFF  A5,B5
26A2:  MOVFF  AD,B9
26A6:  CALL   0290
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
26AA:  MOVFF  AB,F65
....................    TXBaDLC.rtr=rtr; 
26AE:  BCF    F65.6
26B0:  BTFSC  xAE.0
26B2:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
26B4:  CLRF   xAF
26B6:  MOVF   xAB,W
26B8:  SUBWF  xAF,W
26BA:  BC    26E4
....................       *txd0=*data; 
26BC:  MOVFF  A9,FE9
26C0:  MOVFF  AA,FEA
26C4:  MOVFF  FEF,B5
26C8:  MOVFF  B1,FEA
26CC:  MOVFF  B0,FE9
26D0:  MOVFF  B5,FEF
....................       txd0++; 
26D4:  INCF   xB0,F
26D6:  BTFSC  FD8.2
26D8:  INCF   xB1,F
....................       data++; 
26DA:  INCF   xA9,F
26DC:  BTFSC  FD8.2
26DE:  INCF   xAA,F
26E0:  INCF   xAF,F
26E2:  BRA    26B6
....................     } 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
26E4:  BSF    F60.3
....................  
....................    CANCON.win=CAN_WIN_RX0; 
26E6:  MOVLW  F1
26E8:  ANDWF  F6F,W
26EA:  MOVWF  F6F
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
26EC:  MOVLW  01
26EE:  MOVWF  01
26F0:  MOVLB  F
26F2:  MOVLB  0
26F4:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             received it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat) 
.................... { 
....................     unsigned int i; 
....................     unsigned int * ptr; 
....................  
....................     if (RXB0CON.rxful) { 
*
29A4:  BTFSS  F60.7
29A6:  BRA    29D6
....................         CANCON.win=CAN_WIN_RX0; 
29A8:  MOVLW  F1
29AA:  ANDWF  F6F,W
29AC:  MOVWF  F6F
....................         stat.buffer=0; 
29AE:  BCF    58.4
....................  
....................         CAN_INT_RXB0IF=0; 
29B0:  BCF    FA4.0
....................  
....................         stat.err_ovfl=COMSTAT.rx0ovfl; 
29B2:  BCF    58.0
29B4:  BTFSC  F74.7
29B6:  BSF    58.0
....................         COMSTAT.rx0ovfl=0; 
29B8:  BCF    F74.7
....................  
....................         if (RXB0CON.rxb0dben) { 
29BA:  BTFSS  F60.2
29BC:  BRA    29D4
....................          stat.filthit=RXB0CON.filthit0; 
29BE:  MOVLW  00
29C0:  BTFSC  F60.0
29C2:  MOVLW  01
29C4:  ANDLW  07
29C6:  MOVWF  00
29C8:  BCF    FD8.0
29CA:  RLCF   00,F
29CC:  MOVLW  F1
29CE:  ANDWF  58,W
29D0:  IORWF  00,W
29D2:  MOVWF  58
....................         } 
....................     } 
29D4:  BRA    2A0E
....................     else if ( RXB1CON.rxful ) 
29D6:  MOVLB  F
29D8:  BTFSS  x50.7
29DA:  BRA    2A06
....................     { 
....................         CANCON.win=CAN_WIN_RX1; 
29DC:  MOVLW  F1
29DE:  ANDWF  F6F,W
29E0:  IORLW  0A
29E2:  MOVWF  F6F
....................         stat.buffer=1; 
29E4:  BSF    58.4
....................  
....................         CAN_INT_RXB1IF=0; 
29E6:  BCF    FA4.1
....................  
....................         stat.err_ovfl=COMSTAT.rx1ovfl; 
29E8:  BCF    58.0
29EA:  BTFSC  F74.6
29EC:  BSF    58.0
....................         COMSTAT.rx1ovfl=0; 
29EE:  BCF    F74.6
....................  
....................         stat.filthit=RXB1CON.filthit; 
29F0:  MOVF   x50,W
29F2:  ANDLW  07
29F4:  ANDLW  07
29F6:  MOVWF  00
29F8:  BCF    FD8.0
29FA:  RLCF   00,F
29FC:  MOVLW  F1
29FE:  ANDWF  58,W
2A00:  IORWF  00,W
2A02:  MOVWF  58
....................     } 
2A04:  BRA    2A0C
....................     else { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
2A06:  MOVLW  00
2A08:  MOVWF  01
2A0A:  BRA    2AA0
2A0C:  MOVLB  0
....................     } 
....................  
....................     len = RXBaDLC.dlc; 
2A0E:  MOVF   F65,W
2A10:  ANDLW  0F
2A12:  MOVWF  x65
....................     stat.rtr=RXBaDLC.rtr; 
2A14:  BCF    58.5
2A16:  BTFSC  F65.6
2A18:  BSF    58.5
....................  
....................     stat.ext=TXRXBaSIDL.ext; 
2A1A:  BCF    58.6
2A1C:  BTFSC  F62.3
2A1E:  BSF    58.6
....................     id=can_get_id(TXRXBaID,stat.ext); 
2A20:  MOVLW  00
2A22:  BTFSC  58.6
2A24:  MOVLW  01
2A26:  MOVWF  xA8
2A28:  MOVLW  0F
2A2A:  MOVWF  xB0
2A2C:  MOVLW  64
2A2E:  MOVWF  xAF
2A30:  MOVFF  A8,B1
2A34:  BRA    22C8
2A36:  MOVFF  03,5C
2A3A:  MOVFF  02,5B
2A3E:  MOVFF  01,5A
2A42:  MOVFF  00,59
....................  
....................     ptr = &TXRXBaD0; 
2A46:  MOVLW  0F
2A48:  MOVWF  xA7
2A4A:  MOVLW  66
2A4C:  MOVWF  xA6
....................     for ( i = 0; i < len; i++ ) { 
2A4E:  CLRF   xA5
2A50:  MOVF   x65,W
2A52:  SUBWF  xA5,W
2A54:  BC    2A7E
....................         *data = *ptr; 
2A56:  MOVFF  A6,FE9
2A5A:  MOVFF  A7,FEA
2A5E:  MOVFF  FEF,AA
2A62:  MOVFF  A4,FEA
2A66:  MOVFF  A3,FE9
2A6A:  MOVFF  AA,FEF
....................         data++; 
2A6E:  INCF   xA3,F
2A70:  BTFSC  FD8.2
2A72:  INCF   xA4,F
....................         ptr++; 
2A74:  INCF   xA6,F
2A76:  BTFSC  FD8.2
2A78:  INCF   xA7,F
2A7A:  INCF   xA5,F
2A7C:  BRA    2A50
....................     } 
....................  
....................     // return to default addressing 
....................     CANCON.win=CAN_WIN_RX0; 
2A7E:  MOVLW  F1
2A80:  ANDWF  F6F,W
2A82:  MOVWF  F6F
....................  
....................     stat.inv=CAN_INT_IRXIF; 
2A84:  BCF    58.7
2A86:  BTFSC  FA4.7
2A88:  BSF    58.7
....................     CAN_INT_IRXIF = 0; 
2A8A:  BCF    FA4.7
....................  
....................     if (stat.buffer) { 
2A8C:  BTFSS  58.4
2A8E:  BRA    2A98
....................       RXB1CON.rxful=0; 
2A90:  MOVLB  F
2A92:  BCF    x50.7
....................     } 
2A94:  BRA    2A9C
2A96:  MOVLB  0
....................     else { 
....................       RXB0CON.rxful=0; 
2A98:  BCF    F60.7
2A9A:  MOVLB  F
....................     } 
....................  
....................     #if CAN_DO_DEBUG 
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr)) { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++) { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
2A9C:  MOVLW  01
2A9E:  MOVWF  01
.................... } 
....................  
....................  
....................  
....................  
.................... #include <BME280.c> 
.................... //************************************************  
.................... //  BME280 Barometric Pressure Sensor  
.................... //  
.................... //  - Datasheet:  https://cdn-shop.adafruit.com/datasheets/BST-BME280_DS001-10.pdf 
.................... //  
.................... //  - Written in CCS PCH C using floating point math  
.................... //  - Several integer math versions of this driver exist but the speed improvement is  
.................... //    not warranted in typical weather station type applications  
.................... //   
.................... //  - Based on a paper posted to thebackshed.com by   
.................... //    https://learn.adafruit.com/adafruit-bme280-humidity-barometric-pressure-temperature-sensor-breakout/wiring-and-test   
.................... //   scl = B5, sDA = B4 
.................... //  
.................... //    Revision - integer algotihm  
.................... //      
.................... //    07/24/2017  
.................... //  
.................... //  Nguyen Trung Truc  
.................... //  08/17/12  
.................... //************************************************  
.................... // place a #use i2c statement in the main program and comment this out if not applicable  
.................... //#define BME280_SDA  PIN_C4 
.................... //#define BME280_SCL  PIN_C3 
.................... //#use i2c(stream=number1, sda=PIN_C4, scl=PIN_C3, MASTER, FAST=400000)  
.................... #use i2c(master, sda=PIN_B4, scl=PIN_B5, FAST, FORCE_SW) // sda = PIN_B4, scl = PIN_B5 
*
04A4:  MOVLW  08
04A6:  MOVWF  01
04A8:  NOP   
04AA:  BCF    F8A.5
04AC:  BCF    F93.5
04AE:  NOP   
04B0:  RLCF   xB4,F
04B2:  BCF    F8A.4
04B4:  BTFSC  FD8.0
04B6:  BSF    F93.4
04B8:  BTFSS  FD8.0
04BA:  BCF    F93.4
04BC:  BSF    F93.5
04BE:  BTFSS  F81.5
04C0:  BRA    04BE
04C2:  DECFSZ 01,F
04C4:  BRA    04A8
04C6:  NOP   
04C8:  BCF    F8A.5
04CA:  BCF    F93.5
04CC:  NOP   
04CE:  BSF    F93.4
04D0:  NOP   
04D2:  NOP   
04D4:  BSF    F93.5
04D6:  BTFSS  F81.5
04D8:  BRA    04D6
04DA:  CLRF   01
04DC:  NOP   
04DE:  BTFSC  F81.4
04E0:  BSF    01.0
04E2:  BCF    F8A.5
04E4:  BCF    F93.5
04E6:  BCF    F8A.4
04E8:  BCF    F93.4
04EA:  RETURN 0
04EC:  MOVLW  08
04EE:  MOVWF  xB5
04F0:  MOVFF  00,B6
04F4:  BSF    F93.4
04F6:  NOP   
04F8:  BSF    F93.5
04FA:  BTFSS  F81.5
04FC:  BRA    04FA
04FE:  BTFSC  F81.4
0500:  BSF    FD8.0
0502:  BTFSS  F81.4
0504:  BCF    FD8.0
0506:  RLCF   01,F
0508:  NOP   
050A:  BCF    F93.5
050C:  BCF    F8A.5
050E:  DECFSZ xB5,F
0510:  BRA    04F4
0512:  BSF    F93.4
0514:  NOP   
0516:  BCF    F8A.4
0518:  MOVF   xB6,W
051A:  BTFSS  FD8.2
051C:  BCF    F93.4
051E:  NOP   
0520:  BSF    F93.5
0522:  BTFSS  F81.5
0524:  BRA    0522
0526:  NOP   
0528:  BCF    F8A.5
052A:  BCF    F93.5
052C:  NOP   
052E:  BCF    F8A.4
0530:  BCF    F93.4
0532:  RETURN 0
.................... #define BME280_ADDRESS 0xEE          // I2C address of BME280 VDD  
.................... #define A_SHRT(var2,y) (var2>0)?(var2>>y):(-((-var2)>>y))  
.................... #define A_SHLT(x,y) (x>0)?(x<<y):(-((-x)<<y))  
....................  
.................... //#include <math.h>  
.................... //#include<stdint.h> 
.................... //calibration values of BME280 
....................          
....................        static unsigned int16 dig_T1; 
....................        static signed int16  dig_T2; 
....................        static signed int16  dig_T3; 
....................        static unsigned int16  dig_P1;// = 37621; 
....................        static signed int16  dig_P2; 
....................        static signed int16  dig_P3; 
....................        static signed int16  dig_P4; 
....................        static signed int16  dig_P5; 
....................        static signed int16  dig_P6; 
....................        static signed int16  dig_P7; 
....................        static signed int16  dig_P8; 
....................        static signed int16  dig_P9; 
....................        static unsigned int8  dig_H1; 
....................        static signed int16  dig_H2; 
....................        static unsigned int8  dig_H3; 
....................        static unsigned int16  dig_H4; 
....................        static signed int16  dig_H5; 
....................        static signed int8   dig_H6; 
....................        static signed int32 t_fine;//var1, var2; 
....................        //static signed int32 var1_p, var2_p, var3_p, var4_p, var5_p, var6_p, var7_p, var8_p, var9_p, var11_p, var33_p, var44_p, var444_p, var4444_p; 
....................        static unsigned int32 adc_P, adc_T; 
....................        static unsigned int16 adc_H; 
....................        static int8 data[8]; 
.................... int8 BME280ReadByte(int8 address); 
.................... int16 BME280ReadInt(int8 address) ; 
.................... int32 BME280Read24(int8 data); 
.................... void BME280WriteByte(int8 address, int8 data) ; 
.................... int1 BME280ReadingCalibration(void); 
.................... void BME280Calibration(); 
.................... void BME280SetSampling(); 
....................  
.................... void init_BME280() 
.................... { 
....................    output_float(PIN_B4); 
*
049C:  BSF    F93.4
....................    output_float(PIN_B5); 
049E:  BSF    F93.5
04A0:  GOTO   2804 (RETURN)
.................... } 
.................... int1 BME280Begin() 
.................... { 
....................     
....................     // check if sensor, i.e. the chip ID is correct 
....................     if(BME280ReadByte(0xD0) != 0x60) 
*
085C:  MOVLW  D0
085E:  MOVWF  xA7
0860:  RCALL  0534
0862:  MOVF   01,W
0864:  SUBLW  60
0866:  BZ    086E
....................         return 0; 
0868:  MOVLW  00
086A:  MOVWF  01
086C:  BRA    089C
....................     // reset the device using soft-reset 
....................     // this makes sure the IIR is off, etc. 
....................     BME280WriteByte(0xE0, 0xB6); 
086E:  MOVLW  E0
0870:  MOVWF  xA3
0872:  MOVLW  B6
0874:  MOVWF  xA4
0876:  RCALL  0590
....................  
....................     // wait for chip to wake up. 
....................     delay_ms(300); 
0878:  MOVLW  02
087A:  MOVWF  xA3
087C:  MOVLW  96
087E:  MOVWF  xA4
0880:  RCALL  05CA
0882:  DECFSZ xA3,F
0884:  BRA    087C
....................  
....................     // if chip is still reading calibration, delay 
....................     while ( BME280ReadingCalibration()) 
0886:  BRA    05F0
0888:  MOVF   01,F
088A:  BZ    0894
....................           delay_ms(100); 
088C:  MOVLW  64
088E:  MOVWF  xA4
0890:  RCALL  05CA
0892:  BRA    0886
....................  
....................     BME280Calibration(); // read trimming parameters, see DS 4.2.2 
0894:  BRA    0730
....................  
....................     BME280SetSampling(); // use defaults 
0896:  BRA    083A
....................  
....................     return 1; 
0898:  MOVLW  01
089A:  MOVWF  01
089C:  GOTO   2808 (RETURN)
.................... } 
.................... void BME280SetSampling() 
.................... { 
....................    
....................      BME280WriteByte(0xF2,0x03); // oversampling x 4, ctr_hum 
*
083A:  MOVLW  F2
083C:  MOVWF  xA3
083E:  MOVLW  03
0840:  MOVWF  xA4
0842:  RCALL  0590
....................      BME280WriteByte(0xF5,0x68); //011 (250ms tstandby) 0100 (filter coefficient =4) 0 (i2c) 
0844:  MOVLW  F5
0846:  MOVWF  xA3
0848:  MOVLW  68
084A:  MOVWF  xA4
084C:  RCALL  0590
....................      BME280WriteByte(0xF4,0x6E);// 011 011 10 temperature oversampling x 4, pressure oversampling x 4, force mode 
084E:  MOVLW  F4
0850:  MOVWF  xA3
0852:  MOVLW  6E
0854:  MOVWF  xA4
0856:  RCALL  0590
0858:  GOTO   0898 (RETURN)
....................     // you must make sure to also set REGISTER_CONTROL after setting the 
....................     // CONTROLHUMID register, otherwise the values won't be applied (see DS 5.4.3) 
....................     // write8(BME280_REGISTER_CONTROLHUMID, _humReg.get()); 
....................     // write8(BME280_REGISTER_CONFIG, _configReg.get()); 
....................     // write8(BME280_REGISTER_CONTROL, _measReg.get()); 
.................... } 
....................  
.................... int8 BME280ReadID()  
.................... //----------------------------------------------  
.................... {  
.................... int8 data;  
....................  
....................    i2c_start();  
....................    i2c_write(0xEE); // 0X77 11101110X IS IC ADDRESS, 0X76 IS 1110 110 
....................    i2c_write(0xD0);  
....................    i2c_start();  
....................    i2c_write(0xEF );  
....................    data=i2c_read(0);  
....................    i2c_stop();  
....................    delay_us(20); 
....................    return(data);  
.................... }  
.................... //---------------------------------------------- 
.................... byte BME280ReadByte(int8 address)  
.................... //----------------------------------------------  
.................... {  
.................... byte data;  
....................  
....................    i2c_start();  
*
0534:  BSF    F93.4
0536:  NOP   
0538:  BSF    F93.5
053A:  NOP   
053C:  BCF    F8A.4
053E:  BCF    F93.4
0540:  NOP   
0542:  BCF    F8A.5
0544:  BCF    F93.5
....................    i2c_write(BME280_ADDRESS);  
0546:  MOVLW  EE
0548:  MOVWF  xB4
054A:  RCALL  04A4
....................    i2c_write(address);  
054C:  MOVFF  A7,B4
0550:  RCALL  04A4
....................    i2c_start();  
0552:  BSF    F93.4
0554:  NOP   
0556:  BSF    F93.5
0558:  NOP   
055A:  BTFSS  F81.5
055C:  BRA    055A
055E:  BCF    F8A.4
0560:  BCF    F93.4
0562:  NOP   
0564:  BCF    F8A.5
0566:  BCF    F93.5
....................    i2c_write(BME280_ADDRESS | 0x01 );  
0568:  MOVLW  EF
056A:  MOVWF  xB4
056C:  RCALL  04A4
....................    data=i2c_read(0);  
056E:  CLRF   00
0570:  RCALL  04EC
0572:  MOVFF  01,A8
....................    i2c_stop();  
0576:  BCF    F93.4
0578:  NOP   
057A:  BSF    F93.5
057C:  BTFSS  F81.5
057E:  BRA    057C
0580:  NOP   
0582:  BRA    0584
0584:  NOP   
0586:  BSF    F93.4
0588:  NOP   
....................    return(data);  
058A:  MOVFF  A8,01
058E:  RETURN 0
.................... }  
....................  
....................  
....................  
.................... //----------------------------------------------  
.................... int16 BME280Read16(int8 address)  
.................... //----------------------------------------------  
.................... {  
.................... byte msb, lsb;  
.................... unsigned int16 temp;  
....................  
....................    i2c_start();  
*
062C:  BSF    F93.4
062E:  NOP   
0630:  BSF    F93.5
0632:  NOP   
0634:  BCF    F8A.4
0636:  BCF    F93.4
0638:  NOP   
063A:  BCF    F8A.5
063C:  BCF    F93.5
....................    i2c_write(BME280_ADDRESS);  
063E:  MOVLW  EE
0640:  MOVWF  xB4
0642:  RCALL  04A4
....................    i2c_write(address);  
0644:  MOVFF  AF,B4
0648:  RCALL  04A4
....................    i2c_start();  
064A:  BSF    F93.4
064C:  NOP   
064E:  BSF    F93.5
0650:  NOP   
0652:  BTFSS  F81.5
0654:  BRA    0652
0656:  BCF    F8A.4
0658:  BCF    F93.4
065A:  NOP   
065C:  BCF    F8A.5
065E:  BCF    F93.5
....................    i2c_write(BME280_ADDRESS | 0x01 );  
0660:  MOVLW  EF
0662:  MOVWF  xB4
0664:  RCALL  04A4
....................    msb = i2c_read();  
0666:  MOVLW  01
0668:  MOVWF  00
066A:  RCALL  04EC
066C:  MOVFF  01,B0
....................    lsb = i2c_read(0);  
0670:  CLRF   00
0672:  RCALL  04EC
0674:  MOVFF  01,B1
....................    i2c_stop();  
0678:  BCF    F93.4
067A:  NOP   
067C:  BSF    F93.5
067E:  BTFSS  F81.5
0680:  BRA    067E
0682:  NOP   
0684:  BRA    0686
0686:  NOP   
0688:  BSF    F93.4
068A:  NOP   
....................    temp = msb*256 + lsb; //(msb<<8)|lsb; 
068C:  CLRF   xB5
068E:  MOVFF  B0,B4
0692:  MOVLW  01
0694:  MOVWF  xB7
0696:  CLRF   xB6
0698:  BRA    060C
069A:  MOVF   xB1,W
069C:  ADDWF  01,W
069E:  MOVWF  xB2
06A0:  MOVLW  00
06A2:  ADDWFC 02,W
06A4:  MOVWF  xB3
....................    return ( temp );  
06A6:  MOVFF  B2,01
06AA:  MOVFF  B3,02
06AE:  RETURN 0
.................... }  
....................  
.................... /**************************************************************************/ 
.................... /*! 
....................     @brief  Reads a signed 16 bit value over I2C or SPI 
.................... */ 
.................... /**************************************************************************/ 
.................... int16 BME280ReadS16(int8 address) 
.................... { 
....................     return ((signed int16)BME280Read16(address)); 
.................... } 
....................  
.................... unsigned int16 BME280Read16_LE(int8 address) 
.................... { 
....................     unsigned int16 temp; 
....................     temp = BME280Read16(address); 
06B0:  MOVFF  A4,AF
06B4:  RCALL  062C
06B6:  MOVFF  02,A6
06BA:  MOVFF  01,A5
....................     temp = (temp >> 8) | (temp << 8); 
06BE:  MOVFF  A6,A7
06C2:  CLRF   xA8
06C4:  MOVFF  A5,03
06C8:  MOVLW  00
06CA:  IORWF  xA6,W
06CC:  MOVWF  xA5
06CE:  MOVF   03,W
06D0:  IORWF  xA8,W
06D2:  MOVWF  xA6
....................     return (unsigned int16)temp; 
06D4:  MOVFF  A5,01
06D8:  MOVFF  A6,02
06DC:  RETURN 0
.................... } 
.................... signed int16 BME280ReadS16_LE(int8 address) 
.................... { 
....................     return (signed int16)BME280Read16_LE(address); 
06DE:  MOVFF  A3,A4
06E2:  RCALL  06B0
06E4:  MOVF   02,W
06E6:  RETURN 0
.................... } 
....................  
.................... //----------------------------------------------  
.................... void BME280WriteByte(int8 address, int8 data)  
.................... //----------------------------------------------  
.................... {  
....................    i2c_start();  
*
0590:  BSF    F93.4
0592:  NOP   
0594:  BSF    F93.5
0596:  NOP   
0598:  BCF    F8A.4
059A:  BCF    F93.4
059C:  NOP   
059E:  BCF    F8A.5
05A0:  BCF    F93.5
....................    i2c_write(BME280_ADDRESS);  
05A2:  MOVLW  EE
05A4:  MOVWF  xB4
05A6:  RCALL  04A4
....................    i2c_write(address);  
05A8:  MOVFF  A3,B4
05AC:  RCALL  04A4
....................    i2c_write(data);  
05AE:  MOVFF  A4,B4
05B2:  RCALL  04A4
....................    i2c_stop();  
05B4:  BCF    F93.4
05B6:  NOP   
05B8:  BSF    F93.5
05BA:  BTFSS  F81.5
05BC:  BRA    05BA
05BE:  NOP   
05C0:  BRA    05C2
05C2:  NOP   
05C4:  BSF    F93.4
05C6:  NOP   
05C8:  RETURN 0
.................... }  
....................  
.................... signed int16 BME280ReadDig_H4()  
.................... {  
....................    unsigned int16 temp;  
....................    byte msb, lsb;  
....................    msb = BME280ReadByte(0xE4);  
*
06E8:  MOVLW  E4
06EA:  MOVWF  xA7
06EC:  RCALL  0534
06EE:  MOVFF  01,A5
....................    lsb = BME280ReadByte(0xE5);  
06F2:  MOVLW  E5
06F4:  MOVWF  xA7
06F6:  RCALL  0534
06F8:  MOVFF  01,A6
....................    temp = ((int16)msb<<4) + (lsb & 0xF);  
06FC:  CLRF   xA8
06FE:  MOVFF  A5,A7
0702:  RLCF   xA7,F
0704:  RLCF   xA8,F
0706:  RLCF   xA7,F
0708:  RLCF   xA8,F
070A:  RLCF   xA7,F
070C:  RLCF   xA8,F
070E:  RLCF   xA7,F
0710:  RLCF   xA8,F
0712:  MOVLW  F0
0714:  ANDWF  xA7,F
0716:  MOVF   xA6,W
0718:  ANDLW  0F
071A:  ADDWF  xA7,W
071C:  MOVWF  xA3
071E:  MOVLW  00
0720:  ADDWFC xA8,W
0722:  MOVWF  xA4
....................    return temp;  
0724:  MOVFF  A3,01
0728:  MOVFF  A4,02
072C:  GOTO   07FC (RETURN)
.................... }  
....................  
.................... void BME280Calibration()  
.................... //----------------------------------------------  
.................... {    
....................   dig_T1 = BME280Read16_LE(0x88); 
0730:  MOVLW  88
0732:  MOVWF  xA4
0734:  RCALL  06B0
0736:  MOVFF  02,1A
073A:  MOVFF  01,19
....................   dig_T2 = BME280ReadS16_LE(0x8A); 
073E:  MOVLW  8A
0740:  MOVWF  xA3
0742:  RCALL  06DE
0744:  MOVFF  02,1C
0748:  MOVFF  01,1B
....................   dig_T3 = BME280ReadS16_LE(0x8C); 
074C:  MOVLW  8C
074E:  MOVWF  xA3
0750:  RCALL  06DE
0752:  MOVFF  02,1E
0756:  MOVFF  01,1D
....................   dig_P1 = BME280Read16_LE(0x8E); 
075A:  MOVLW  8E
075C:  MOVWF  xA4
075E:  RCALL  06B0
0760:  MOVFF  02,20
0764:  MOVFF  01,1F
....................   dig_P2 = BME280ReadS16_LE(0x90); 
0768:  MOVLW  90
076A:  MOVWF  xA3
076C:  RCALL  06DE
076E:  MOVFF  02,22
0772:  MOVFF  01,21
....................   dig_P3 = BME280ReadS16_LE(0x92); 
0776:  MOVLW  92
0778:  MOVWF  xA3
077A:  RCALL  06DE
077C:  MOVFF  02,24
0780:  MOVFF  01,23
....................   dig_P4 = BME280ReadS16_LE(0x94); 
0784:  MOVLW  94
0786:  MOVWF  xA3
0788:  RCALL  06DE
078A:  MOVFF  02,26
078E:  MOVFF  01,25
....................   dig_P5 = BME280ReadS16_LE(0x96); 
0792:  MOVLW  96
0794:  MOVWF  xA3
0796:  RCALL  06DE
0798:  MOVFF  02,28
079C:  MOVFF  01,27
....................   dig_P6 = BME280ReadS16_LE(0x98); 
07A0:  MOVLW  98
07A2:  MOVWF  xA3
07A4:  RCALL  06DE
07A6:  MOVFF  02,2A
07AA:  MOVFF  01,29
....................   dig_P7 = BME280ReadS16_LE(0x9A); 
07AE:  MOVLW  9A
07B0:  MOVWF  xA3
07B2:  RCALL  06DE
07B4:  MOVFF  02,2C
07B8:  MOVFF  01,2B
....................   dig_P8 = BME280ReadS16_LE(0x9C); 
07BC:  MOVLW  9C
07BE:  MOVWF  xA3
07C0:  RCALL  06DE
07C2:  MOVFF  02,2E
07C6:  MOVFF  01,2D
....................   dig_P9 = BME280ReadS16_LE(0x9E); 
07CA:  MOVLW  9E
07CC:  MOVWF  xA3
07CE:  RCALL  06DE
07D0:  MOVFF  02,30
07D4:  MOVFF  01,2F
....................    
....................   dig_H1 = BME280ReadByte(0xA1); 
07D8:  MOVLW  A1
07DA:  MOVWF  xA7
07DC:  RCALL  0534
07DE:  MOVFF  01,31
....................   dig_H2 = BME280ReadS16_LE(0xE1); 
07E2:  MOVLW  E1
07E4:  MOVWF  xA3
07E6:  RCALL  06DE
07E8:  MOVFF  02,33
07EC:  MOVFF  01,32
....................   dig_H3 = BME280ReadByte(0xE3); 
07F0:  MOVLW  E3
07F2:  MOVWF  xA7
07F4:  RCALL  0534
07F6:  MOVFF  01,34
....................   dig_H4 = BME280ReadDig_H4(); //285 
07FA:  BRA    06E8
07FC:  MOVFF  02,36
0800:  MOVFF  01,35
....................   dig_H5 = (BME280ReadByte(0xE6)<<4)|(BME280ReadByte(0xE5) >>4) ; 
0804:  MOVLW  E6
0806:  MOVWF  xA7
0808:  RCALL  0534
080A:  SWAPF  01,W
080C:  MOVWF  xA3
080E:  MOVLW  F0
0810:  ANDWF  xA3,F
0812:  MOVLW  E5
0814:  MOVWF  xA7
0816:  RCALL  0534
0818:  SWAPF  01,W
081A:  MOVWF  00
081C:  MOVLW  0F
081E:  ANDWF  00,F
0820:  MOVF   00,W
0822:  IORWF  xA3,W
0824:  CLRF   03
0826:  MOVWF  37
0828:  MOVFF  03,38
....................   dig_H6 = (signed int8)BME280ReadByte(0xE7); 
082C:  MOVLW  E7
082E:  MOVWF  xA7
0830:  RCALL  0534
0832:  MOVFF  01,39
0836:  GOTO   0896 (RETURN)
....................    
.................... } 
....................  
.................... //----------------------------------------------  
....................  
....................  
.................... // Read the uncompensated temperature value  
.................... //----------------------------------------------  
....................  
.................... void BurstRead() 
.................... { 
....................      // int8 data[8];   
....................       i2c_start();  
*
08A0:  BSF    F93.4
08A2:  NOP   
08A4:  BSF    F93.5
08A6:  NOP   
08A8:  BCF    F8A.4
08AA:  BCF    F93.4
08AC:  NOP   
08AE:  BCF    F8A.5
08B0:  BCF    F93.5
....................       i2c_write(BME280_ADDRESS);  
08B2:  MOVLW  EE
08B4:  MOVWF  xB4
08B6:  RCALL  04A4
....................       i2c_write(0xF7);  
08B8:  MOVLW  F7
08BA:  MOVWF  xB4
08BC:  RCALL  04A4
....................        
....................       i2c_start();  
08BE:  BSF    F93.4
08C0:  NOP   
08C2:  BSF    F93.5
08C4:  NOP   
08C6:  BTFSS  F81.5
08C8:  BRA    08C6
08CA:  BCF    F8A.4
08CC:  BCF    F93.4
08CE:  NOP   
08D0:  BCF    F8A.5
08D2:  BCF    F93.5
....................       i2c_write(BME280_ADDRESS | 0x01);  
08D4:  MOVLW  EF
08D6:  MOVWF  xB4
08D8:  RCALL  04A4
....................       data[0] = i2c_read();  
08DA:  MOVLW  01
08DC:  MOVWF  00
08DE:  RCALL  04EC
08E0:  MOVFF  01,48
....................       data[1] = i2c_read(); 
08E4:  MOVLW  01
08E6:  MOVWF  00
08E8:  RCALL  04EC
08EA:  MOVFF  01,49
....................       data[2] = i2c_read(); 
08EE:  MOVLW  01
08F0:  MOVWF  00
08F2:  RCALL  04EC
08F4:  MOVFF  01,4A
....................       data[3] = i2c_read(); 
08F8:  MOVLW  01
08FA:  MOVWF  00
08FC:  RCALL  04EC
08FE:  MOVFF  01,4B
....................       data[4] = i2c_read(); 
0902:  MOVLW  01
0904:  MOVWF  00
0906:  RCALL  04EC
0908:  MOVFF  01,4C
....................       data[5] = i2c_read(); 
090C:  MOVLW  01
090E:  MOVWF  00
0910:  RCALL  04EC
0912:  MOVFF  01,4D
....................       data[6] = i2c_read(); 
0916:  MOVLW  01
0918:  MOVWF  00
091A:  RCALL  04EC
091C:  MOVFF  01,4E
....................       data[7] = i2c_read();     
0920:  MOVLW  01
0922:  MOVWF  00
0924:  RCALL  04EC
0926:  MOVFF  01,4F
....................       i2c_stop(); 
092A:  BCF    F93.4
092C:  NOP   
092E:  BSF    F93.5
0930:  BTFSS  F81.5
0932:  BRA    0930
0934:  NOP   
0936:  BRA    0938
0938:  NOP   
093A:  BSF    F93.4
093C:  NOP   
....................      //ata[5]=data[5]&0xF0; 
....................       adc_P = make32(0,data[0],data[1],data[2]); 
093E:  CLRF   41
0940:  MOVFF  48,40
0944:  MOVFF  49,3F
0948:  MOVFF  4A,3E
....................      // adc_T = make32(0,data[3],data[4]); 
....................       adc_T  = make32(0,data[3],data[4],data[5]); 
094C:  CLRF   45
094E:  MOVFF  4B,44
0952:  MOVFF  4C,43
0956:  MOVFF  4D,42
....................       adc_H = make16(data[6],data[7]); 
095A:  MOVFF  4E,47
095E:  MOVFF  4F,46
0962:  GOTO   2826 (RETURN)
....................        
....................       // Read register 0xF6 (MSB), 0xF7 (LSB), and 0xF8 (XLSB)  
.................... } 
....................  
.................... unsigned int32 BME280Read24(int8 data) 
.................... { 
....................  unsigned int32 value; 
....................  int8 msb, lsb, xlsb;  
....................   
....................       i2c_start();  
....................       i2c_write(BME280_ADDRESS);  
....................       i2c_write(data);  
....................        
....................       i2c_start();  
....................       i2c_write(BME280_ADDRESS | 0x01);  
....................        
....................       // Read register 0xF6 (MSB), 0xF7 (LSB), and 0xF8 (XLSB)  
....................        
....................       msb = i2c_read();  
....................       lsb = i2c_read();  
....................       xlsb = i2c_read(0); // NACK on last read  
....................       i2c_stop(); //*/  
....................        
....................       value = make32(0,msb,lsb,xlsb); // (msb<<16)|(lsb<<8)|xlsb ; 
....................  
....................     return value; 
.................... } 
....................  
....................  
.................... int1 BME280ReadingCalibration(void) 
*
05F0:  MOVLW  F3
05F2:  MOVWF  xA7
05F4:  RCALL  0534
05F6:  MOVFF  01,A3
.................... { 
....................  // unsigned int8 const rStatus = BME280ReadByte(0xF3); 
....................   int8 rStatus = BME280ReadByte(0xF3); 
....................   return (rStatus & (1 << 0)) != 0; // return 1 if bus is busy reading 1<<0  is 1 shifted left 0 times 
05FA:  MOVF   xA3,W
05FC:  ANDLW  01
05FE:  BNZ   0604
0600:  MOVLW  00
0602:  BRA    0606
0604:  MOVLW  01
0606:  MOVWF  01
0608:  GOTO   0888 (RETURN)
.................... } 
....................  
.................... void BME280TakeForcedMeasurement() 
.................... {    
....................      
....................      BME280WriteByte(0xF4,0x6E); //011 011 01 pressure oversampling x 4, temperature oversampling x 4, forced mode 
....................      while (BME280ReadByte(0xF4) & 0x08)  // wait until measurement has been completed, otherwise we would read the values from the last measurement 
....................       delay_us(10); 
....................     } 
....................      
....................  
.................... float BME280ReadTemperature(void) 
.................... { 
....................  
....................   
....................    signed int32 var1, var2; 
....................  
....................     //signed int32 adc_T = BME280Read24(0xFA); //FA THE TEMPERATURE REGISTER 
....................     if (adc_T == 0x800000) // value in case temp measurement was disabled 
*
0B48:  MOVF   42,F
0B4A:  BNZ   0B64
0B4C:  MOVF   43,F
0B4E:  BNZ   0B64
0B50:  MOVF   44,W
0B52:  SUBLW  80
0B54:  BNZ   0B64
0B56:  MOVF   45,F
0B58:  BNZ   0B64
....................         return 0; 
0B5A:  CLRF   00
0B5C:  CLRF   01
0B5E:  CLRF   02
0B60:  CLRF   03
0B62:  BRA    0E7E
....................     adc_T >>= 4; 
0B64:  RRCF   45,F
0B66:  RRCF   44,F
0B68:  RRCF   43,F
0B6A:  RRCF   42,F
0B6C:  RRCF   45,F
0B6E:  RRCF   44,F
0B70:  RRCF   43,F
0B72:  RRCF   42,F
0B74:  RRCF   45,F
0B76:  RRCF   44,F
0B78:  RRCF   43,F
0B7A:  RRCF   42,F
0B7C:  RRCF   45,F
0B7E:  RRCF   44,F
0B80:  RRCF   43,F
0B82:  RRCF   42,F
0B84:  MOVLW  0F
0B86:  ANDWF  45,F
....................  
....................     var1 = ((((adc_T>>3) - ((signed int32)dig_T1 <<1)))*((signed int32)dig_T2)) >> 11; 
0B88:  RRCF   45,W
0B8A:  MOVWF  xB3
0B8C:  RRCF   44,W
0B8E:  MOVWF  xB2
0B90:  RRCF   43,W
0B92:  MOVWF  xB1
0B94:  RRCF   42,W
0B96:  MOVWF  xB0
0B98:  RRCF   xB3,F
0B9A:  RRCF   xB2,F
0B9C:  RRCF   xB1,F
0B9E:  RRCF   xB0,F
0BA0:  RRCF   xB3,F
0BA2:  RRCF   xB2,F
0BA4:  RRCF   xB1,F
0BA6:  RRCF   xB0,F
0BA8:  MOVLW  1F
0BAA:  ANDWF  xB3,F
0BAC:  CLRF   xB7
0BAE:  CLRF   xB6
0BB0:  MOVFF  1A,B5
0BB4:  MOVFF  19,B4
0BB8:  BCF    FD8.0
0BBA:  RLCF   19,W
0BBC:  MOVWF  00
0BBE:  RLCF   1A,W
0BC0:  MOVWF  01
0BC2:  RLCF   xB6,W
0BC4:  MOVWF  02
0BC6:  RLCF   xB7,W
0BC8:  MOVWF  03
0BCA:  MOVF   00,W
0BCC:  SUBWF  xB0,F
0BCE:  MOVF   01,W
0BD0:  SUBWFB xB1,F
0BD2:  MOVF   02,W
0BD4:  SUBWFB xB2,F
0BD6:  MOVF   03,W
0BD8:  SUBWFB xB3,F
0BDA:  MOVFF  1B,00
0BDE:  MOVFF  1C,01
0BE2:  CLRF   02
0BE4:  CLRF   03
0BE6:  BTFSS  1C.7
0BE8:  BRA    0BEE
0BEA:  DECF   02,F
0BEC:  DECF   03,F
0BEE:  MOVFF  03,B7
0BF2:  MOVFF  02,B6
0BF6:  MOVFF  01,B5
0BFA:  MOVFF  00,B4
0BFE:  MOVFF  B3,C2
0C02:  MOVFF  B2,C1
0C06:  MOVFF  B1,C0
0C0A:  MOVFF  B0,BF
0C0E:  MOVFF  03,C6
0C12:  MOVFF  02,C5
0C16:  MOVFF  01,C4
0C1A:  MOVFF  00,C3
0C1E:  RCALL  0966
0C20:  MOVFF  03,B3
0C24:  MOVFF  02,B2
0C28:  MOVFF  01,B1
0C2C:  MOVFF  00,B0
0C30:  CLRF   03
0C32:  RRCF   xB3,W
0C34:  MOVWF  02
0C36:  RRCF   xB2,W
0C38:  MOVWF  01
0C3A:  RRCF   xB1,W
0C3C:  MOVWF  00
0C3E:  RRCF   02,F
0C40:  RRCF   01,F
0C42:  RRCF   00,F
0C44:  RRCF   02,F
0C46:  RRCF   01,F
0C48:  RRCF   00,F
0C4A:  MOVLW  1F
0C4C:  ANDWF  02,F
0C4E:  MOVFF  03,A6
0C52:  MOVFF  02,A5
0C56:  MOVFF  01,A4
0C5A:  MOVFF  00,A3
....................               
....................     var2 = (((((adc_T>>4) - ((signed int32)dig_T1)) * ((adc_T>>4) - ((signed int32)dig_T1))) >> 12) *((signed int32)dig_T3)) >> 14; 
0C5E:  RRCF   45,W
0C60:  MOVWF  xB3
0C62:  RRCF   44,W
0C64:  MOVWF  xB2
0C66:  RRCF   43,W
0C68:  MOVWF  xB1
0C6A:  RRCF   42,W
0C6C:  MOVWF  xB0
0C6E:  RRCF   xB3,F
0C70:  RRCF   xB2,F
0C72:  RRCF   xB1,F
0C74:  RRCF   xB0,F
0C76:  RRCF   xB3,F
0C78:  RRCF   xB2,F
0C7A:  RRCF   xB1,F
0C7C:  RRCF   xB0,F
0C7E:  RRCF   xB3,F
0C80:  RRCF   xB2,F
0C82:  RRCF   xB1,F
0C84:  RRCF   xB0,F
0C86:  MOVLW  0F
0C88:  ANDWF  xB3,F
0C8A:  CLRF   02
0C8C:  CLRF   03
0C8E:  MOVF   19,W
0C90:  SUBWF  xB0,F
0C92:  MOVF   1A,W
0C94:  SUBWFB xB1,F
0C96:  MOVF   02,W
0C98:  SUBWFB xB2,F
0C9A:  MOVF   03,W
0C9C:  SUBWFB xB3,F
0C9E:  RRCF   45,W
0CA0:  MOVWF  xB8
0CA2:  RRCF   44,W
0CA4:  MOVWF  xB7
0CA6:  RRCF   43,W
0CA8:  MOVWF  xB6
0CAA:  RRCF   42,W
0CAC:  MOVWF  xB5
0CAE:  RRCF   xB8,F
0CB0:  RRCF   xB7,F
0CB2:  RRCF   xB6,F
0CB4:  RRCF   xB5,F
0CB6:  RRCF   xB8,F
0CB8:  RRCF   xB7,F
0CBA:  RRCF   xB6,F
0CBC:  RRCF   xB5,F
0CBE:  RRCF   xB8,F
0CC0:  RRCF   xB7,F
0CC2:  RRCF   xB6,F
0CC4:  RRCF   xB5,F
0CC6:  MOVLW  0F
0CC8:  ANDWF  xB8,F
0CCA:  CLRF   02
0CCC:  CLRF   03
0CCE:  MOVF   19,W
0CD0:  SUBWF  xB5,W
0CD2:  MOVWF  00
0CD4:  MOVF   1A,W
0CD6:  SUBWFB xB6,W
0CD8:  MOVWF  01
0CDA:  MOVF   02,W
0CDC:  SUBWFB xB7,W
0CDE:  MOVWF  02
0CE0:  MOVF   03,W
0CE2:  SUBWFB xB8,W
0CE4:  MOVWF  03
0CE6:  MOVWF  xB8
0CE8:  MOVFF  02,B7
0CEC:  MOVFF  01,B6
0CF0:  MOVFF  00,B5
0CF4:  MOVFF  B3,C2
0CF8:  MOVFF  B2,C1
0CFC:  MOVFF  B1,C0
0D00:  MOVFF  B0,BF
0D04:  MOVWF  xC6
0D06:  MOVFF  02,C5
0D0A:  MOVFF  01,C4
0D0E:  MOVFF  00,C3
0D12:  RCALL  0966
0D14:  MOVFF  03,B3
0D18:  MOVFF  01,B0
0D1C:  MOVFF  02,B1
0D20:  MOVFF  03,B2
0D24:  CLRF   xB3
0D26:  RRCF   xB3,F
0D28:  RRCF   xB2,F
0D2A:  RRCF   xB1,F
0D2C:  RRCF   xB0,F
0D2E:  RRCF   xB3,F
0D30:  RRCF   xB2,F
0D32:  RRCF   xB1,F
0D34:  RRCF   xB0,F
0D36:  RRCF   xB3,F
0D38:  RRCF   xB2,F
0D3A:  RRCF   xB1,F
0D3C:  RRCF   xB0,F
0D3E:  RRCF   xB3,F
0D40:  RRCF   xB2,F
0D42:  RRCF   xB1,F
0D44:  RRCF   xB0,F
0D46:  MOVLW  0F
0D48:  ANDWF  xB3,F
0D4A:  MOVFF  1D,00
0D4E:  MOVFF  1E,01
0D52:  CLRF   02
0D54:  CLRF   03
0D56:  BTFSS  1E.7
0D58:  BRA    0D5E
0D5A:  DECF   02,F
0D5C:  DECF   03,F
0D5E:  MOVFF  03,B9
0D62:  MOVFF  02,B8
0D66:  MOVFF  01,B7
0D6A:  MOVFF  00,B6
0D6E:  MOVFF  B3,C2
0D72:  MOVFF  B2,C1
0D76:  MOVFF  B1,C0
0D7A:  MOVFF  B0,BF
0D7E:  MOVFF  03,C6
0D82:  MOVFF  02,C5
0D86:  MOVFF  01,C4
0D8A:  MOVFF  00,C3
0D8E:  RCALL  0966
0D90:  MOVFF  03,B3
0D94:  MOVFF  02,B2
0D98:  MOVFF  01,B1
0D9C:  MOVFF  00,B0
0DA0:  CLRF   03
0DA2:  RRCF   xB3,W
0DA4:  MOVWF  02
0DA6:  RRCF   xB2,W
0DA8:  MOVWF  01
0DAA:  RRCF   xB1,W
0DAC:  MOVWF  00
0DAE:  RRCF   02,F
0DB0:  RRCF   01,F
0DB2:  RRCF   00,F
0DB4:  RRCF   02,F
0DB6:  RRCF   01,F
0DB8:  RRCF   00,F
0DBA:  RRCF   02,F
0DBC:  RRCF   01,F
0DBE:  RRCF   00,F
0DC0:  RRCF   02,F
0DC2:  RRCF   01,F
0DC4:  RRCF   00,F
0DC6:  RRCF   02,F
0DC8:  RRCF   01,F
0DCA:  RRCF   00,F
0DCC:  MOVLW  03
0DCE:  ANDWF  02,F
0DD0:  MOVFF  03,AA
0DD4:  MOVFF  02,A9
0DD8:  MOVFF  01,A8
0DDC:  MOVFF  00,A7
....................     
....................    t_fine = var1 + var2; 
0DE0:  MOVF   xA7,W
0DE2:  ADDWF  xA3,W
0DE4:  MOVWF  3A
0DE6:  MOVF   xA8,W
0DE8:  ADDWFC xA4,W
0DEA:  MOVWF  3B
0DEC:  MOVF   xA9,W
0DEE:  ADDWFC xA5,W
0DF0:  MOVWF  3C
0DF2:  MOVF   xAA,W
0DF4:  ADDWFC xA6,W
0DF6:  MOVWF  3D
....................  
....................     float T= (t_fine * 5 + 128) >> 8; 
0DF8:  MOVFF  3D,C2
0DFC:  MOVFF  3C,C1
0E00:  MOVFF  3B,C0
0E04:  MOVFF  3A,BF
0E08:  CLRF   xC6
0E0A:  CLRF   xC5
0E0C:  CLRF   xC4
0E0E:  MOVLW  05
0E10:  MOVWF  xC3
0E12:  RCALL  0966
0E14:  MOVFF  03,B2
0E18:  MOVFF  02,B1
0E1C:  MOVFF  01,B0
0E20:  MOVFF  00,AF
0E24:  MOVLW  80
0E26:  ADDWF  xAF,F
0E28:  MOVLW  00
0E2A:  ADDWFC xB0,F
0E2C:  ADDWFC xB1,F
0E2E:  ADDWFC xB2,F
0E30:  MOVFF  B0,00
0E34:  MOVFF  B1,01
0E38:  MOVFF  B2,02
0E3C:  CLRF   03
0E3E:  MOVFF  03,B7
0E42:  MOVFF  B2,B6
0E46:  MOVFF  B1,B5
0E4A:  MOVFF  B0,B4
0E4E:  RCALL  09BA
0E50:  MOVFF  03,AE
0E54:  MOVFF  02,AD
0E58:  MOVFF  01,AC
0E5C:  MOVFF  00,AB
....................     return T/100; 
0E60:  MOVFF  AE,B6
0E64:  MOVFF  AD,B5
0E68:  MOVFF  AC,B4
0E6C:  MOVFF  AB,B3
0E70:  CLRF   xBA
0E72:  CLRF   xB9
0E74:  MOVLW  48
0E76:  MOVWF  xB8
0E78:  MOVLW  85
0E7A:  MOVWF  xB7
0E7C:  RCALL  09EE
0E7E:  GOTO   2832 (RETURN)
....................      
.................... } 
....................  
.................... unsigned int32 BME280_compensate_P_int32() 
.................... { 
....................  
....................  //signed int32 adc_P = BME280Read24(0xF7); //FA THE TEMPERATURE REGISTER 
.................... if (adc_P == 0x800000) // value in case temp measurement was disabled 
....................         return 0; 
....................     adc_P >>= 4; 
....................     signed int32 var1, var2, var3; 
....................     unsigned int32 p; 
....................     //BME280ReadTemperature(); //must be done to get t_fine 
....................   t_fine = t_fine +2000; 
.................... var1 = (((signed int32)t_fine)>>1) - (unsigned int32)64000; 
.................... //delay_us(100); 
....................  //var11_p = (int32)(168278)>>1; 
.................... var2 = (((var1>>2) * (var1>>2)) >> 11 ) * ((signed int32)dig_P6);  // dig_p6 is negative 
.................... var2 = var2 + ((var1*((signed int32)dig_P5))<<1);   // dig_p5 is negative therefore left shift is OK ? sfhit left is ok 
.................... //var33_p = ((signed int32)dig_P5)<<1; 
.................... var2 = A_SHRT(var2,2)+(((signed int32)dig_P4)<<16); 
.................... var3=(signed int32)dig_P2 * var1; 
.................... var3 = A_SHRT(var3,1); 
.................... var3 = ((dig_P3 * ((A_SHRT(var1,2) *A_SHRT(var1,2)) >> 13 )) >> 3)+ var3; 
.................... var1= A_SHRT(var3,18); 
....................  
....................  //var5_p = var1; 
....................  var1 = (32768+var1)*(signed int32)dig_P1; 
....................  var1 = A_SHRT(var1,15); 
....................  
....................  
.................... if (var1 == 0) 
.................... { 
.................... return 0; // avoid exception caused by division by zero 
.................... } 
.................... p = (((unsigned int32)(((signed int32)1048576) - adc_P)- A_SHRT(var2,12)))*3125; 
.................... //p = (((unsigned int32)(((signed int32)1048576) - adc_P)-(var2>>12)))*3125; 
....................  
.................... if (p < 0x80000000) 
.................... { 
.................... p = (p << 1) / ((unsigned int32)var1); 
.................... } 
.................... else 
.................... { 
.................... p = (p / (unsigned int32)var1) * 2; 
.................... } 
.................... var1 = (((signed int32)dig_P9) * ((signed int32)(((p>>3) * (p>>3))>>13)))>>12; 
....................  
.................... //var2 = (((signed int32)(p>>2)) * ((signed int32)dig_P8))>>13; 
.................... var2 = (((signed int32)(p>>2)) * ((signed int32)dig_P8)); 
.................... var2 = A_SHRT(var2,13); 
.................... //var2 = (((signed int32)(p>>2)) * ((signed int32)dig_P8))>>13; 
....................  
.................... p = (unsigned int32)((signed int32)p + ((signed int32)(var1 + var2 + dig_P7) >> 4)); 
.................... return p; 
.................... } 
....................     
.................... float Calculate_Pess()  
.................... {  
....................    float var1, var2, p;  
....................     if (adc_P == 0x800000) // value in case temp measurement was disabled 
*
1B40:  MOVF   3E,F
1B42:  BNZ   1B5C
1B44:  MOVF   3F,F
1B46:  BNZ   1B5C
1B48:  MOVF   40,W
1B4A:  SUBLW  80
1B4C:  BNZ   1B5C
1B4E:  MOVF   41,F
1B50:  BNZ   1B5C
....................         return 0; 
1B52:  CLRF   00
1B54:  CLRF   01
1B56:  CLRF   02
1B58:  CLRF   03
1B5A:  BRA    22C4
....................     adc_P >>= 4; 
1B5C:  RRCF   41,F
1B5E:  RRCF   40,F
1B60:  RRCF   3F,F
1B62:  RRCF   3E,F
1B64:  RRCF   41,F
1B66:  RRCF   40,F
1B68:  RRCF   3F,F
1B6A:  RRCF   3E,F
1B6C:  RRCF   41,F
1B6E:  RRCF   40,F
1B70:  RRCF   3F,F
1B72:  RRCF   3E,F
1B74:  RRCF   41,F
1B76:  RRCF   40,F
1B78:  RRCF   3F,F
1B7A:  RRCF   3E,F
1B7C:  MOVLW  0F
1B7E:  ANDWF  41,F
....................    var1 = ((float)t_fine/2.0) - 64000.0;  
1B80:  MOVFF  3D,B2
1B84:  MOVFF  3C,B1
1B88:  MOVFF  3B,B0
1B8C:  MOVFF  3A,AF
1B90:  BRA    1786
1B92:  MOVFF  03,B2
1B96:  MOVFF  02,B1
1B9A:  MOVFF  01,B0
1B9E:  MOVFF  00,AF
1BA2:  MOVFF  03,B6
1BA6:  MOVFF  02,B5
1BAA:  MOVFF  01,B4
1BAE:  MOVFF  00,B3
1BB2:  CLRF   xBA
1BB4:  CLRF   xB9
1BB6:  CLRF   xB8
1BB8:  MOVLW  80
1BBA:  MOVWF  xB7
1BBC:  CALL   09EE
1BC0:  MOVFF  03,B2
1BC4:  MOVFF  02,B1
1BC8:  MOVFF  01,B0
1BCC:  MOVFF  00,AF
1BD0:  BSF    FD8.1
1BD2:  MOVFF  03,B6
1BD6:  MOVFF  02,B5
1BDA:  MOVFF  01,B4
1BDE:  MOVFF  00,B3
1BE2:  CLRF   xBA
1BE4:  CLRF   xB9
1BE6:  MOVLW  7A
1BE8:  MOVWF  xB8
1BEA:  MOVLW  8E
1BEC:  MOVWF  xB7
1BEE:  RCALL  17DE
1BF0:  MOVFF  03,A6
1BF4:  MOVFF  02,A5
1BF8:  MOVFF  01,A4
1BFC:  MOVFF  00,A3
....................    var2 = var1 * var1 * ((float)dig_P6) / 32768.0;  
1C00:  MOVFF  A6,BA
1C04:  MOVFF  A5,B9
1C08:  MOVFF  A4,B8
1C0C:  MOVFF  A3,B7
1C10:  MOVFF  A6,BE
1C14:  MOVFF  A5,BD
1C18:  MOVFF  A4,BC
1C1C:  MOVFF  A3,BB
1C20:  CALL   0EA2
1C24:  MOVFF  03,B2
1C28:  MOVFF  02,B1
1C2C:  MOVFF  01,B0
1C30:  MOVFF  00,AF
1C34:  MOVFF  2A,B4
1C38:  MOVFF  29,B3
1C3C:  RCALL  1A48
1C3E:  MOVFF  B2,BA
1C42:  MOVFF  B1,B9
1C46:  MOVFF  B0,B8
1C4A:  MOVFF  AF,B7
1C4E:  MOVFF  03,BE
1C52:  MOVFF  02,BD
1C56:  MOVFF  01,BC
1C5A:  MOVFF  00,BB
1C5E:  CALL   0EA2
1C62:  MOVFF  03,B2
1C66:  MOVFF  02,B1
1C6A:  MOVFF  01,B0
1C6E:  MOVFF  00,AF
1C72:  MOVFF  03,B6
1C76:  MOVFF  02,B5
1C7A:  MOVFF  01,B4
1C7E:  MOVFF  00,B3
1C82:  CLRF   xBA
1C84:  CLRF   xB9
1C86:  CLRF   xB8
1C88:  MOVLW  8E
1C8A:  MOVWF  xB7
1C8C:  CALL   09EE
1C90:  MOVFF  03,AA
1C94:  MOVFF  02,A9
1C98:  MOVFF  01,A8
1C9C:  MOVFF  00,A7
....................    var2 = var2 + var1 * ((float)dig_P5) * 2.0;  
1CA0:  MOVFF  28,B4
1CA4:  MOVFF  27,B3
1CA8:  RCALL  1A48
1CAA:  MOVFF  A6,BA
1CAE:  MOVFF  A5,B9
1CB2:  MOVFF  A4,B8
1CB6:  MOVFF  A3,B7
1CBA:  MOVFF  03,BE
1CBE:  MOVFF  02,BD
1CC2:  MOVFF  01,BC
1CC6:  MOVFF  00,BB
1CCA:  CALL   0EA2
1CCE:  MOVFF  03,B2
1CD2:  MOVFF  02,B1
1CD6:  MOVFF  01,B0
1CDA:  MOVFF  00,AF
1CDE:  MOVFF  03,BA
1CE2:  MOVFF  02,B9
1CE6:  MOVFF  01,B8
1CEA:  MOVFF  00,B7
1CEE:  CLRF   xBE
1CF0:  CLRF   xBD
1CF2:  CLRF   xBC
1CF4:  MOVLW  80
1CF6:  MOVWF  xBB
1CF8:  CALL   0EA2
1CFC:  BCF    FD8.1
1CFE:  MOVFF  AA,B6
1D02:  MOVFF  A9,B5
1D06:  MOVFF  A8,B4
1D0A:  MOVFF  A7,B3
1D0E:  MOVFF  03,BA
1D12:  MOVFF  02,B9
1D16:  MOVFF  01,B8
1D1A:  MOVFF  00,B7
1D1E:  RCALL  17DE
1D20:  MOVFF  03,AA
1D24:  MOVFF  02,A9
1D28:  MOVFF  01,A8
1D2C:  MOVFF  00,A7
....................    var2 = (var2/4.0)+(((float)dig_P4) * 65536.0);  
1D30:  MOVFF  AA,B6
1D34:  MOVFF  A9,B5
1D38:  MOVFF  A8,B4
1D3C:  MOVFF  A7,B3
1D40:  CLRF   xBA
1D42:  CLRF   xB9
1D44:  CLRF   xB8
1D46:  MOVLW  81
1D48:  MOVWF  xB7
1D4A:  CALL   09EE
1D4E:  MOVFF  03,B2
1D52:  MOVFF  02,B1
1D56:  MOVFF  01,B0
1D5A:  MOVFF  00,AF
1D5E:  MOVFF  26,B4
1D62:  MOVFF  25,B3
1D66:  RCALL  1A48
1D68:  MOVFF  03,B6
1D6C:  MOVFF  02,B5
1D70:  MOVFF  01,B4
1D74:  MOVFF  00,B3
1D78:  MOVFF  03,BA
1D7C:  MOVFF  02,B9
1D80:  MOVFF  01,B8
1D84:  MOVFF  00,B7
1D88:  CLRF   xBE
1D8A:  CLRF   xBD
1D8C:  CLRF   xBC
1D8E:  MOVLW  8F
1D90:  MOVWF  xBB
1D92:  CALL   0EA2
1D96:  BCF    FD8.1
1D98:  MOVFF  B2,B6
1D9C:  MOVFF  B1,B5
1DA0:  MOVFF  B0,B4
1DA4:  MOVFF  AF,B3
1DA8:  MOVFF  03,BA
1DAC:  MOVFF  02,B9
1DB0:  MOVFF  01,B8
1DB4:  MOVFF  00,B7
1DB8:  RCALL  17DE
1DBA:  MOVFF  03,AA
1DBE:  MOVFF  02,A9
1DC2:  MOVFF  01,A8
1DC6:  MOVFF  00,A7
....................    var1 = (((float)dig_P3) * var1 * var1 / 524288.0 + ((float)dig_P2) * var1) / 524288.0;  
1DCA:  MOVFF  24,B4
1DCE:  MOVFF  23,B3
1DD2:  RCALL  1A48
1DD4:  MOVFF  03,B2
1DD8:  MOVFF  02,B1
1DDC:  MOVFF  01,B0
1DE0:  MOVFF  00,AF
1DE4:  MOVFF  03,BA
1DE8:  MOVFF  02,B9
1DEC:  MOVFF  01,B8
1DF0:  MOVFF  00,B7
1DF4:  MOVFF  A6,BE
1DF8:  MOVFF  A5,BD
1DFC:  MOVFF  A4,BC
1E00:  MOVFF  A3,BB
1E04:  CALL   0EA2
1E08:  MOVFF  03,B2
1E0C:  MOVFF  02,B1
1E10:  MOVFF  01,B0
1E14:  MOVFF  00,AF
1E18:  MOVFF  03,BA
1E1C:  MOVFF  02,B9
1E20:  MOVFF  01,B8
1E24:  MOVFF  00,B7
1E28:  MOVFF  A6,BE
1E2C:  MOVFF  A5,BD
1E30:  MOVFF  A4,BC
1E34:  MOVFF  A3,BB
1E38:  CALL   0EA2
1E3C:  MOVFF  03,B2
1E40:  MOVFF  02,B1
1E44:  MOVFF  01,B0
1E48:  MOVFF  00,AF
1E4C:  MOVFF  03,B6
1E50:  MOVFF  02,B5
1E54:  MOVFF  01,B4
1E58:  MOVFF  00,B3
1E5C:  CLRF   xBA
1E5E:  CLRF   xB9
1E60:  CLRF   xB8
1E62:  MOVLW  92
1E64:  MOVWF  xB7
1E66:  CALL   09EE
1E6A:  MOVFF  03,B2
1E6E:  MOVFF  02,B1
1E72:  MOVFF  01,B0
1E76:  MOVFF  00,AF
1E7A:  MOVFF  22,B4
1E7E:  MOVFF  21,B3
1E82:  RCALL  1A48
1E84:  MOVFF  03,B6
1E88:  MOVFF  02,B5
1E8C:  MOVFF  01,B4
1E90:  MOVFF  00,B3
1E94:  MOVFF  03,BA
1E98:  MOVFF  02,B9
1E9C:  MOVFF  01,B8
1EA0:  MOVFF  00,B7
1EA4:  MOVFF  A6,BE
1EA8:  MOVFF  A5,BD
1EAC:  MOVFF  A4,BC
1EB0:  MOVFF  A3,BB
1EB4:  CALL   0EA2
1EB8:  BCF    FD8.1
1EBA:  MOVFF  B2,B6
1EBE:  MOVFF  B1,B5
1EC2:  MOVFF  B0,B4
1EC6:  MOVFF  AF,B3
1ECA:  MOVFF  03,BA
1ECE:  MOVFF  02,B9
1ED2:  MOVFF  01,B8
1ED6:  MOVFF  00,B7
1EDA:  RCALL  17DE
1EDC:  MOVFF  03,B2
1EE0:  MOVFF  02,B1
1EE4:  MOVFF  01,B0
1EE8:  MOVFF  00,AF
1EEC:  MOVFF  03,B6
1EF0:  MOVFF  02,B5
1EF4:  MOVFF  01,B4
1EF8:  MOVFF  00,B3
1EFC:  CLRF   xBA
1EFE:  CLRF   xB9
1F00:  CLRF   xB8
1F02:  MOVLW  92
1F04:  MOVWF  xB7
1F06:  CALL   09EE
1F0A:  MOVFF  03,A6
1F0E:  MOVFF  02,A5
1F12:  MOVFF  01,A4
1F16:  MOVFF  00,A3
....................    var1 = (1.0 + var1 / 32768.0)*((float)dig_P1);  
1F1A:  MOVFF  A6,B6
1F1E:  MOVFF  A5,B5
1F22:  MOVFF  A4,B4
1F26:  MOVFF  A3,B3
1F2A:  CLRF   xBA
1F2C:  CLRF   xB9
1F2E:  CLRF   xB8
1F30:  MOVLW  8E
1F32:  MOVWF  xB7
1F34:  CALL   09EE
1F38:  BCF    FD8.1
1F3A:  CLRF   xB6
1F3C:  CLRF   xB5
1F3E:  CLRF   xB4
1F40:  MOVLW  7F
1F42:  MOVWF  xB3
1F44:  MOVFF  03,BA
1F48:  MOVFF  02,B9
1F4C:  MOVFF  01,B8
1F50:  MOVFF  00,B7
1F54:  RCALL  17DE
1F56:  MOVFF  03,B2
1F5A:  MOVFF  02,B1
1F5E:  MOVFF  01,B0
1F62:  MOVFF  00,AF
1F66:  MOVFF  20,B4
1F6A:  MOVFF  1F,B3
1F6E:  BRA    1A90
1F70:  MOVFF  B2,BA
1F74:  MOVFF  B1,B9
1F78:  MOVFF  B0,B8
1F7C:  MOVFF  AF,B7
1F80:  MOVFF  03,BE
1F84:  MOVFF  02,BD
1F88:  MOVFF  01,BC
1F8C:  MOVFF  00,BB
1F90:  CALL   0EA2
1F94:  MOVFF  03,A6
1F98:  MOVFF  02,A5
1F9C:  MOVFF  01,A4
1FA0:  MOVFF  00,A3
....................    if (var1 == 0.0)  
1FA4:  MOVFF  A6,B2
1FA8:  MOVFF  A5,B1
1FAC:  MOVFF  A4,B0
1FB0:  MOVFF  A3,AF
1FB4:  CLRF   xB6
1FB6:  CLRF   xB5
1FB8:  CLRF   xB4
1FBA:  CLRF   xB3
1FBC:  BRA    1AC8
1FBE:  BNZ   1FC0
....................    {  
....................    //return 0; // avoid exception caused by division by zero  
....................    }  
....................    p = 1048576.0 - (float)adc_P;  
1FC0:  MOVFF  41,B7
1FC4:  MOVFF  40,B6
1FC8:  MOVFF  3F,B5
1FCC:  MOVFF  3E,B4
1FD0:  CALL   09BA
1FD4:  BSF    FD8.1
1FD6:  CLRF   xB6
1FD8:  CLRF   xB5
1FDA:  CLRF   xB4
1FDC:  MOVLW  93
1FDE:  MOVWF  xB3
1FE0:  MOVFF  03,BA
1FE4:  MOVFF  02,B9
1FE8:  MOVFF  01,B8
1FEC:  MOVFF  00,B7
1FF0:  CALL   17DE
1FF4:  MOVFF  03,AE
1FF8:  MOVFF  02,AD
1FFC:  MOVFF  01,AC
2000:  MOVFF  00,AB
....................    p = (p - (var2 / 4096.0)) * 6250.0 / var1;  
2004:  MOVFF  AA,B6
2008:  MOVFF  A9,B5
200C:  MOVFF  A8,B4
2010:  MOVFF  A7,B3
2014:  CLRF   xBA
2016:  CLRF   xB9
2018:  CLRF   xB8
201A:  MOVLW  8B
201C:  MOVWF  xB7
201E:  CALL   09EE
2022:  BSF    FD8.1
2024:  MOVFF  AE,B6
2028:  MOVFF  AD,B5
202C:  MOVFF  AC,B4
2030:  MOVFF  AB,B3
2034:  MOVFF  03,BA
2038:  MOVFF  02,B9
203C:  MOVFF  01,B8
2040:  MOVFF  00,B7
2044:  CALL   17DE
2048:  MOVFF  03,B2
204C:  MOVFF  02,B1
2050:  MOVFF  01,B0
2054:  MOVFF  00,AF
2058:  MOVFF  03,BA
205C:  MOVFF  02,B9
2060:  MOVFF  01,B8
2064:  MOVFF  00,B7
2068:  CLRF   xBE
206A:  MOVLW  50
206C:  MOVWF  xBD
206E:  MOVLW  43
2070:  MOVWF  xBC
2072:  MOVLW  8B
2074:  MOVWF  xBB
2076:  CALL   0EA2
207A:  MOVFF  03,B2
207E:  MOVFF  02,B1
2082:  MOVFF  01,B0
2086:  MOVFF  00,AF
208A:  MOVFF  03,B6
208E:  MOVFF  02,B5
2092:  MOVFF  01,B4
2096:  MOVFF  00,B3
209A:  MOVFF  A6,BA
209E:  MOVFF  A5,B9
20A2:  MOVFF  A4,B8
20A6:  MOVFF  A3,B7
20AA:  CALL   09EE
20AE:  MOVFF  03,AE
20B2:  MOVFF  02,AD
20B6:  MOVFF  01,AC
20BA:  MOVFF  00,AB
....................    var1 = ((float)dig_P9) * p * p / 2147483648.0;  
20BE:  MOVFF  30,B4
20C2:  MOVFF  2F,B3
20C6:  RCALL  1A48
20C8:  MOVFF  03,B2
20CC:  MOVFF  02,B1
20D0:  MOVFF  01,B0
20D4:  MOVFF  00,AF
20D8:  MOVFF  03,BA
20DC:  MOVFF  02,B9
20E0:  MOVFF  01,B8
20E4:  MOVFF  00,B7
20E8:  MOVFF  AE,BE
20EC:  MOVFF  AD,BD
20F0:  MOVFF  AC,BC
20F4:  MOVFF  AB,BB
20F8:  CALL   0EA2
20FC:  MOVFF  03,B2
2100:  MOVFF  02,B1
2104:  MOVFF  01,B0
2108:  MOVFF  00,AF
210C:  MOVFF  03,BA
2110:  MOVFF  02,B9
2114:  MOVFF  01,B8
2118:  MOVFF  00,B7
211C:  MOVFF  AE,BE
2120:  MOVFF  AD,BD
2124:  MOVFF  AC,BC
2128:  MOVFF  AB,BB
212C:  CALL   0EA2
2130:  MOVFF  03,B2
2134:  MOVFF  02,B1
2138:  MOVFF  01,B0
213C:  MOVFF  00,AF
2140:  MOVFF  03,B6
2144:  MOVFF  02,B5
2148:  MOVFF  01,B4
214C:  MOVFF  00,B3
2150:  CLRF   xBA
2152:  CLRF   xB9
2154:  CLRF   xB8
2156:  MOVLW  9E
2158:  MOVWF  xB7
215A:  CALL   09EE
215E:  MOVFF  03,A6
2162:  MOVFF  02,A5
2166:  MOVFF  01,A4
216A:  MOVFF  00,A3
....................    var2 = p * ((float)dig_P8) / 32768.0;  
216E:  MOVFF  2E,B4
2172:  MOVFF  2D,B3
2176:  RCALL  1A48
2178:  MOVFF  AE,BA
217C:  MOVFF  AD,B9
2180:  MOVFF  AC,B8
2184:  MOVFF  AB,B7
2188:  MOVFF  03,BE
218C:  MOVFF  02,BD
2190:  MOVFF  01,BC
2194:  MOVFF  00,BB
2198:  CALL   0EA2
219C:  MOVFF  03,B2
21A0:  MOVFF  02,B1
21A4:  MOVFF  01,B0
21A8:  MOVFF  00,AF
21AC:  MOVFF  03,B6
21B0:  MOVFF  02,B5
21B4:  MOVFF  01,B4
21B8:  MOVFF  00,B3
21BC:  CLRF   xBA
21BE:  CLRF   xB9
21C0:  CLRF   xB8
21C2:  MOVLW  8E
21C4:  MOVWF  xB7
21C6:  CALL   09EE
21CA:  MOVFF  03,AA
21CE:  MOVFF  02,A9
21D2:  MOVFF  01,A8
21D6:  MOVFF  00,A7
....................    p = p + (var1 + var2 + ((float)dig_P7)) / 16.0;  
21DA:  BCF    FD8.1
21DC:  MOVFF  A6,B6
21E0:  MOVFF  A5,B5
21E4:  MOVFF  A4,B4
21E8:  MOVFF  A3,B3
21EC:  MOVFF  AA,BA
21F0:  MOVFF  A9,B9
21F4:  MOVFF  A8,B8
21F8:  MOVFF  A7,B7
21FC:  CALL   17DE
2200:  MOVFF  03,B2
2204:  MOVFF  02,B1
2208:  MOVFF  01,B0
220C:  MOVFF  00,AF
2210:  MOVFF  2C,B4
2214:  MOVFF  2B,B3
2218:  RCALL  1A48
221A:  BCF    FD8.1
221C:  MOVFF  B2,B6
2220:  MOVFF  B1,B5
2224:  MOVFF  B0,B4
2228:  MOVFF  AF,B3
222C:  MOVFF  03,BA
2230:  MOVFF  02,B9
2234:  MOVFF  01,B8
2238:  MOVFF  00,B7
223C:  CALL   17DE
2240:  MOVFF  03,B2
2244:  MOVFF  02,B1
2248:  MOVFF  01,B0
224C:  MOVFF  00,AF
2250:  MOVFF  03,B6
2254:  MOVFF  02,B5
2258:  MOVFF  01,B4
225C:  MOVFF  00,B3
2260:  CLRF   xBA
2262:  CLRF   xB9
2264:  CLRF   xB8
2266:  MOVLW  83
2268:  MOVWF  xB7
226A:  CALL   09EE
226E:  BCF    FD8.1
2270:  MOVFF  AE,B6
2274:  MOVFF  AD,B5
2278:  MOVFF  AC,B4
227C:  MOVFF  AB,B3
2280:  MOVFF  03,BA
2284:  MOVFF  02,B9
2288:  MOVFF  01,B8
228C:  MOVFF  00,B7
2290:  CALL   17DE
2294:  MOVFF  03,AE
2298:  MOVFF  02,AD
229C:  MOVFF  01,AC
22A0:  MOVFF  00,AB
.................... return p/100; 
22A4:  MOVFF  AE,B6
22A8:  MOVFF  AD,B5
22AC:  MOVFF  AC,B4
22B0:  MOVFF  AB,B3
22B4:  CLRF   xBA
22B6:  CLRF   xB9
22B8:  MOVLW  48
22BA:  MOVWF  xB8
22BC:  MOVLW  85
22BE:  MOVWF  xB7
22C0:  CALL   09EE
22C4:  GOTO   2912 (RETURN)
....................     
.................... }  
....................   
....................  
.................... float BME280ReadHumidity(void) { 
*
11E2:  MOVLW  FD
11E4:  MOVWF  xAF
11E6:  CALL   062C
11EA:  CLRF   xA6
11EC:  CLRF   xA5
11EE:  MOVFF  02,A4
11F2:  MOVFF  01,A3
....................     //readTemperature(); // must be done first to get  
....................      
....................  
....................     int32 adc_H = BME280Read16(0xFD);// BME280_REGISTER_HUMIDDATA 
....................      
....................     if (adc_H == 0x8000) // value in case humidity measurement was disabled 
11F6:  MOVF   xA3,F
11F8:  BNZ   1212
11FA:  MOVF   xA4,W
11FC:  SUBLW  80
11FE:  BNZ   1212
1200:  MOVF   xA5,F
1202:  BNZ   1212
1204:  MOVF   xA6,F
1206:  BNZ   1212
....................         return 0; 
1208:  CLRF   00
120A:  CLRF   01
120C:  CLRF   02
120E:  CLRF   03
1210:  BRA    1782
....................     signed int32  v_x1_u32r; 
....................  
....................     v_x1_u32r = (t_fine - ((signed int32)76800)); 
1212:  MOVLW  00
1214:  SUBWF  3A,W
1216:  MOVWF  xA7
1218:  MOVLW  2C
121A:  SUBWFB 3B,W
121C:  MOVWF  xA8
121E:  MOVLW  01
1220:  SUBWFB 3C,W
1222:  MOVWF  xA9
1224:  MOVLW  00
1226:  SUBWFB 3D,W
1228:  MOVWF  xAA
....................  
....................     v_x1_u32r = (((((adc_H << 14) - (((int32)dig_H4) << 20) - 
....................                     (((signed int32)dig_H5) * v_x1_u32r)) + ((signed int32)16384)) >> 15) * 
....................                  (((((((v_x1_u32r * ((int32)dig_H6)) >> 10) * 
....................                       (((v_x1_u32r * ((signed int32)dig_H3)) >> 11) + ((signed int32)32768))) >> 10) + 
....................                     ((signed int32)2097152)) * ((signed int32)dig_H2) + 8192) >> 14)); 
122A:  CLRF   xB0
122C:  RLCF   xA3,W
122E:  MOVWF  xB1
1230:  RLCF   xA4,W
1232:  MOVWF  xB2
1234:  RLCF   xA5,W
1236:  MOVWF  xB3
1238:  RLCF   xB1,F
123A:  RLCF   xB2,F
123C:  RLCF   xB3,F
123E:  RLCF   xB1,F
1240:  RLCF   xB2,F
1242:  RLCF   xB3,F
1244:  RLCF   xB1,F
1246:  RLCF   xB2,F
1248:  RLCF   xB3,F
124A:  RLCF   xB1,F
124C:  RLCF   xB2,F
124E:  RLCF   xB3,F
1250:  RLCF   xB1,F
1252:  RLCF   xB2,F
1254:  RLCF   xB3,F
1256:  MOVLW  C0
1258:  ANDWF  xB1,F
125A:  CLRF   xB7
125C:  CLRF   xB6
125E:  CLRF   00
1260:  CLRF   01
1262:  RLCF   35,W
1264:  MOVWF  02
1266:  RLCF   36,W
1268:  MOVWF  03
126A:  RLCF   02,F
126C:  RLCF   03,F
126E:  RLCF   02,F
1270:  RLCF   03,F
1272:  RLCF   02,F
1274:  RLCF   03,F
1276:  MOVLW  F0
1278:  ANDWF  02,F
127A:  MOVF   00,W
127C:  SUBWF  xB0,F
127E:  MOVF   01,W
1280:  SUBWFB xB1,F
1282:  MOVF   02,W
1284:  SUBWFB xB2,F
1286:  MOVF   03,W
1288:  SUBWFB xB3,F
128A:  CLRF   xB7
128C:  CLRF   xB6
128E:  MOVFF  38,B5
1292:  MOVFF  37,B4
1296:  BTFSS  38.7
1298:  BRA    129E
129A:  DECF   xB6,F
129C:  DECF   xB7,F
129E:  MOVFF  B7,C2
12A2:  MOVFF  B6,C1
12A6:  MOVFF  B5,C0
12AA:  MOVFF  B4,BF
12AE:  MOVFF  AA,C6
12B2:  MOVFF  A9,C5
12B6:  MOVFF  A8,C4
12BA:  MOVFF  A7,C3
12BE:  CALL   0966
12C2:  MOVF   00,W
12C4:  SUBWF  xB0,F
12C6:  MOVF   01,W
12C8:  SUBWFB xB1,F
12CA:  MOVF   02,W
12CC:  SUBWFB xB2,F
12CE:  MOVF   03,W
12D0:  SUBWFB xB3,F
12D2:  MOVLW  40
12D4:  ADDWF  xB1,F
12D6:  MOVLW  00
12D8:  ADDWFC xB2,F
12DA:  ADDWFC xB3,F
12DC:  MOVFF  B1,B0
12E0:  MOVFF  B2,B1
12E4:  MOVFF  B3,B2
12E8:  CLRF   xB3
12EA:  RRCF   xB3,F
12EC:  RRCF   xB2,F
12EE:  RRCF   xB1,F
12F0:  RRCF   xB0,F
12F2:  RRCF   xB3,F
12F4:  RRCF   xB2,F
12F6:  RRCF   xB1,F
12F8:  RRCF   xB0,F
12FA:  RRCF   xB3,F
12FC:  RRCF   xB2,F
12FE:  RRCF   xB1,F
1300:  RRCF   xB0,F
1302:  RRCF   xB3,F
1304:  RRCF   xB2,F
1306:  RRCF   xB1,F
1308:  RRCF   xB0,F
130A:  RRCF   xB3,F
130C:  RRCF   xB2,F
130E:  RRCF   xB1,F
1310:  RRCF   xB0,F
1312:  RRCF   xB3,F
1314:  RRCF   xB2,F
1316:  RRCF   xB1,F
1318:  RRCF   xB0,F
131A:  RRCF   xB3,F
131C:  RRCF   xB2,F
131E:  RRCF   xB1,F
1320:  RRCF   xB0,F
1322:  MOVLW  01
1324:  ANDWF  xB3,F
1326:  MOVFF  39,00
132A:  CLRF   01
132C:  CLRF   02
132E:  CLRF   03
1330:  MOVFF  AA,C2
1334:  MOVFF  A9,C1
1338:  MOVFF  A8,C0
133C:  MOVFF  A7,BF
1340:  MOVFF  03,C6
1344:  MOVFF  02,C5
1348:  MOVFF  01,C4
134C:  MOVFF  39,C3
1350:  CALL   0966
1354:  MOVFF  03,B8
1358:  MOVFF  01,B5
135C:  MOVFF  02,B6
1360:  MOVFF  03,B7
1364:  CLRF   xB8
1366:  RRCF   xB8,F
1368:  RRCF   xB7,F
136A:  RRCF   xB6,F
136C:  RRCF   xB5,F
136E:  RRCF   xB8,F
1370:  RRCF   xB7,F
1372:  RRCF   xB6,F
1374:  RRCF   xB5,F
1376:  MOVLW  3F
1378:  ANDWF  xB8,F
137A:  MOVFF  34,00
137E:  CLRF   01
1380:  CLRF   02
1382:  CLRF   03
1384:  MOVFF  03,BD
1388:  MOVFF  02,BC
138C:  MOVFF  01,BB
1390:  MOVFF  34,BA
1394:  MOVFF  AA,C2
1398:  MOVFF  A9,C1
139C:  MOVFF  A8,C0
13A0:  MOVFF  A7,BF
13A4:  MOVFF  03,C6
13A8:  MOVFF  02,C5
13AC:  MOVFF  01,C4
13B0:  MOVFF  34,C3
13B4:  CALL   0966
13B8:  MOVFF  03,BD
13BC:  MOVFF  01,BA
13C0:  MOVFF  02,BB
13C4:  MOVFF  03,BC
13C8:  CLRF   xBD
13CA:  RRCF   xBD,F
13CC:  RRCF   xBC,F
13CE:  RRCF   xBB,F
13D0:  RRCF   xBA,F
13D2:  RRCF   xBD,F
13D4:  RRCF   xBC,F
13D6:  RRCF   xBB,F
13D8:  RRCF   xBA,F
13DA:  RRCF   xBD,F
13DC:  RRCF   xBC,F
13DE:  RRCF   xBB,F
13E0:  RRCF   xBA,F
13E2:  MOVLW  1F
13E4:  ANDWF  xBD,F
13E6:  MOVFF  BA,00
13EA:  MOVLW  80
13EC:  ADDWF  xBB,W
13EE:  MOVWF  01
13F0:  MOVLW  00
13F2:  ADDWFC xBC,W
13F4:  MOVWF  02
13F6:  MOVLW  00
13F8:  ADDWFC xBD,W
13FA:  MOVWF  03
13FC:  MOVWF  xBD
13FE:  MOVFF  02,BC
1402:  MOVFF  01,BB
1406:  MOVFF  BA,BA
140A:  MOVFF  B8,C2
140E:  MOVFF  B7,C1
1412:  MOVFF  B6,C0
1416:  MOVFF  B5,BF
141A:  MOVWF  xC6
141C:  MOVFF  02,C5
1420:  MOVFF  01,C4
1424:  MOVFF  BA,C3
1428:  CALL   0966
142C:  MOVFF  03,B8
1430:  MOVFF  01,B5
1434:  MOVFF  02,B6
1438:  MOVFF  03,B7
143C:  CLRF   xB8
143E:  RRCF   xB8,F
1440:  RRCF   xB7,F
1442:  RRCF   xB6,F
1444:  RRCF   xB5,F
1446:  RRCF   xB8,F
1448:  RRCF   xB7,F
144A:  RRCF   xB6,F
144C:  RRCF   xB5,F
144E:  MOVLW  3F
1450:  ANDWF  xB8,F
1452:  MOVLW  20
1454:  ADDWF  xB7,F
1456:  MOVLW  00
1458:  ADDWFC xB8,F
145A:  MOVFF  32,00
145E:  MOVFF  33,01
1462:  CLRF   02
1464:  CLRF   03
1466:  BTFSS  33.7
1468:  BRA    146E
146A:  DECF   02,F
146C:  DECF   03,F
146E:  MOVFF  03,BE
1472:  MOVFF  02,BD
1476:  MOVFF  01,BC
147A:  MOVFF  00,BB
147E:  MOVFF  B8,C2
1482:  MOVFF  B7,C1
1486:  MOVFF  B6,C0
148A:  MOVFF  B5,BF
148E:  MOVFF  03,C6
1492:  MOVFF  02,C5
1496:  MOVFF  01,C4
149A:  MOVFF  00,C3
149E:  CALL   0966
14A2:  MOVFF  03,B8
14A6:  MOVFF  02,B7
14AA:  MOVFF  01,B6
14AE:  MOVFF  00,B5
14B2:  MOVLW  20
14B4:  ADDWF  xB6,F
14B6:  MOVLW  00
14B8:  ADDWFC xB7,F
14BA:  ADDWFC xB8,F
14BC:  CLRF   03
14BE:  RRCF   xB8,W
14C0:  MOVWF  02
14C2:  RRCF   xB7,W
14C4:  MOVWF  01
14C6:  RRCF   xB6,W
14C8:  MOVWF  00
14CA:  RRCF   02,F
14CC:  RRCF   01,F
14CE:  RRCF   00,F
14D0:  RRCF   02,F
14D2:  RRCF   01,F
14D4:  RRCF   00,F
14D6:  RRCF   02,F
14D8:  RRCF   01,F
14DA:  RRCF   00,F
14DC:  RRCF   02,F
14DE:  RRCF   01,F
14E0:  RRCF   00,F
14E2:  RRCF   02,F
14E4:  RRCF   01,F
14E6:  RRCF   00,F
14E8:  MOVLW  03
14EA:  ANDWF  02,F
14EC:  MOVFF  03,B8
14F0:  MOVFF  02,B7
14F4:  MOVFF  01,B6
14F8:  MOVFF  00,B5
14FC:  MOVFF  B3,C2
1500:  MOVFF  B2,C1
1504:  MOVFF  B1,C0
1508:  MOVFF  B0,BF
150C:  MOVFF  03,C6
1510:  MOVFF  02,C5
1514:  MOVFF  01,C4
1518:  MOVFF  00,C3
151C:  CALL   0966
1520:  MOVFF  03,AA
1524:  MOVFF  02,A9
1528:  MOVFF  01,A8
152C:  MOVFF  00,A7
....................  
....................     v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7)*((signed int32)dig_H1)) >> 4)); 
1530:  CLRF   xB3
1532:  RRCF   xAA,W
1534:  MOVWF  xB2
1536:  RRCF   xA9,W
1538:  MOVWF  xB1
153A:  RRCF   xA8,W
153C:  MOVWF  xB0
153E:  RRCF   xB2,F
1540:  RRCF   xB1,F
1542:  RRCF   xB0,F
1544:  RRCF   xB2,F
1546:  RRCF   xB1,F
1548:  RRCF   xB0,F
154A:  RRCF   xB2,F
154C:  RRCF   xB1,F
154E:  RRCF   xB0,F
1550:  RRCF   xB2,F
1552:  RRCF   xB1,F
1554:  RRCF   xB0,F
1556:  RRCF   xB2,F
1558:  RRCF   xB1,F
155A:  RRCF   xB0,F
155C:  RRCF   xB2,F
155E:  RRCF   xB1,F
1560:  RRCF   xB0,F
1562:  MOVLW  01
1564:  ANDWF  xB2,F
1566:  CLRF   03
1568:  RRCF   xAA,W
156A:  MOVWF  02
156C:  RRCF   xA9,W
156E:  MOVWF  01
1570:  RRCF   xA8,W
1572:  MOVWF  00
1574:  RRCF   02,F
1576:  RRCF   01,F
1578:  RRCF   00,F
157A:  RRCF   02,F
157C:  RRCF   01,F
157E:  RRCF   00,F
1580:  RRCF   02,F
1582:  RRCF   01,F
1584:  RRCF   00,F
1586:  RRCF   02,F
1588:  RRCF   01,F
158A:  RRCF   00,F
158C:  RRCF   02,F
158E:  RRCF   01,F
1590:  RRCF   00,F
1592:  RRCF   02,F
1594:  RRCF   01,F
1596:  RRCF   00,F
1598:  MOVLW  01
159A:  ANDWF  02,F
159C:  MOVFF  03,B8
15A0:  MOVFF  02,B7
15A4:  MOVFF  01,B6
15A8:  MOVFF  00,B5
15AC:  MOVFF  B3,C2
15B0:  MOVFF  B2,C1
15B4:  MOVFF  B1,C0
15B8:  MOVFF  B0,BF
15BC:  MOVFF  03,C6
15C0:  MOVFF  02,C5
15C4:  MOVFF  01,C4
15C8:  MOVFF  00,C3
15CC:  CALL   0966
15D0:  MOVFF  03,B3
15D4:  MOVFF  02,B2
15D8:  MOVFF  01,B1
15DC:  MOVFF  00,B0
15E0:  RRCF   xB3,F
15E2:  RRCF   xB2,F
15E4:  RRCF   xB1,F
15E6:  RRCF   xB0,F
15E8:  RRCF   xB3,F
15EA:  RRCF   xB2,F
15EC:  RRCF   xB1,F
15EE:  RRCF   xB0,F
15F0:  RRCF   xB3,F
15F2:  RRCF   xB2,F
15F4:  RRCF   xB1,F
15F6:  RRCF   xB0,F
15F8:  RRCF   xB3,F
15FA:  RRCF   xB2,F
15FC:  RRCF   xB1,F
15FE:  RRCF   xB0,F
1600:  RRCF   xB3,F
1602:  RRCF   xB2,F
1604:  RRCF   xB1,F
1606:  RRCF   xB0,F
1608:  RRCF   xB3,F
160A:  RRCF   xB2,F
160C:  RRCF   xB1,F
160E:  RRCF   xB0,F
1610:  RRCF   xB3,F
1612:  RRCF   xB2,F
1614:  RRCF   xB1,F
1616:  RRCF   xB0,F
1618:  MOVLW  01
161A:  ANDWF  xB3,F
161C:  MOVFF  31,00
1620:  CLRF   01
1622:  CLRF   02
1624:  CLRF   03
1626:  MOVFF  03,B9
162A:  MOVFF  02,B8
162E:  MOVFF  01,B7
1632:  MOVFF  31,B6
1636:  MOVFF  B3,C2
163A:  MOVFF  B2,C1
163E:  MOVFF  B1,C0
1642:  MOVFF  B0,BF
1646:  MOVFF  03,C6
164A:  MOVFF  02,C5
164E:  MOVFF  01,C4
1652:  MOVFF  31,C3
1656:  CALL   0966
165A:  MOVFF  03,B3
165E:  MOVFF  02,B2
1662:  MOVFF  01,B1
1666:  MOVFF  00,B0
166A:  RRCF   03,W
166C:  MOVWF  03
166E:  RRCF   02,W
1670:  MOVWF  02
1672:  RRCF   01,W
1674:  MOVWF  01
1676:  RRCF   00,W
1678:  MOVWF  00
167A:  RRCF   03,F
167C:  RRCF   02,F
167E:  RRCF   01,F
1680:  RRCF   00,F
1682:  RRCF   03,F
1684:  RRCF   02,F
1686:  RRCF   01,F
1688:  RRCF   00,F
168A:  RRCF   03,F
168C:  RRCF   02,F
168E:  RRCF   01,F
1690:  RRCF   00,F
1692:  MOVLW  0F
1694:  ANDWF  03,F
1696:  MOVF   00,W
1698:  SUBWF  xA7,F
169A:  MOVF   01,W
169C:  SUBWFB xA8,F
169E:  MOVF   02,W
16A0:  SUBWFB xA9,F
16A2:  MOVF   03,W
16A4:  SUBWFB xAA,F
....................     v_x1_u32r = (v_x1_u32r < 0) ? 0 : v_x1_u32r; 
16A6:  BTFSS  xAA.7
16A8:  BRA    16B4
16AA:  CLRF   00
16AC:  CLRF   01
16AE:  CLRF   02
16B0:  CLRF   03
16B2:  BRA    16C4
16B4:  MOVFF  A7,00
16B8:  MOVFF  A8,01
16BC:  MOVFF  A9,02
16C0:  MOVFF  AA,03
16C4:  MOVFF  03,AA
16C8:  MOVFF  02,A9
16CC:  MOVFF  01,A8
16D0:  MOVFF  00,A7
....................     v_x1_u32r = (v_x1_u32r > 419430400) ? 419430400 : v_x1_u32r; 
16D4:  BTFSC  xAA.7
16D6:  BRA    16FC
16D8:  MOVF   xAA,W
16DA:  SUBLW  18
16DC:  BC    16FC
16DE:  XORLW  FF
16E0:  BNZ   16F0
16E2:  MOVF   xA9,F
16E4:  BNZ   16F0
16E6:  MOVF   xA8,F
16E8:  BNZ   16F0
16EA:  MOVF   xA7,W
16EC:  SUBLW  00
16EE:  BC    16FC
16F0:  CLRF   00
16F2:  CLRF   01
16F4:  CLRF   02
16F6:  MOVLW  19
16F8:  MOVWF  03
16FA:  BRA    170C
16FC:  MOVFF  A7,00
1700:  MOVFF  A8,01
1704:  MOVFF  A9,02
1708:  MOVFF  AA,03
170C:  MOVFF  03,AA
1710:  MOVFF  02,A9
1714:  MOVFF  01,A8
1718:  MOVFF  00,A7
....................     float h = (v_x1_u32r>>12); 
171C:  CLRF   03
171E:  RRCF   xAA,W
1720:  MOVWF  02
1722:  RRCF   xA9,W
1724:  MOVWF  01
1726:  RRCF   xA8,W
1728:  MOVWF  00
172A:  RRCF   02,F
172C:  RRCF   01,F
172E:  RRCF   00,F
1730:  RRCF   02,F
1732:  RRCF   01,F
1734:  RRCF   00,F
1736:  RRCF   02,F
1738:  RRCF   01,F
173A:  RRCF   00,F
173C:  MOVLW  0F
173E:  ANDWF  02,F
1740:  MOVFF  03,B7
1744:  MOVFF  02,B6
1748:  MOVFF  01,B5
174C:  MOVFF  00,B4
1750:  CALL   09BA
1754:  MOVFF  03,AE
1758:  MOVFF  02,AD
175C:  MOVFF  01,AC
1760:  MOVFF  00,AB
....................     return  h / 1024.0; 
1764:  MOVFF  AE,B6
1768:  MOVFF  AD,B5
176C:  MOVFF  AC,B4
1770:  MOVFF  AB,B3
1774:  CLRF   xBA
1776:  CLRF   xB9
1778:  CLRF   xB8
177A:  MOVLW  89
177C:  MOVWF  xB7
177E:  CALL   09EE
1782:  GOTO   28A2 (RETURN)
.................... } 
....................  
.................... // Read the uncompensated pressure value  
.................... //----------------------------------------------  
....................  
....................  
....................  
....................  
.................... //#include <sht71.c> 
.................... //#include <MAX31855.c> 
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... //#include <LCDdriver.c> 
.................... int16 ms; 
....................  
.................... #int_timer2 
.................... void isr_timer2(void) { 
....................    ms++; //keep a running timer that increments every milli-second 
*
00AE:  INCF   56,F
00B0:  BTFSC  FD8.2
00B2:  INCF   57,F
00B4:  BCF    F9E.1
00B6:  GOTO   0060
.................... } 
....................  
.................... void main() { 
*
26F6:  CLRF   FF8
26F8:  BCF    FD0.7
26FA:  BSF    07.7
26FC:  MOVLW  20
26FE:  MOVWF  FAF
2700:  MOVLW  A6
2702:  MOVWF  FAC
2704:  MOVLW  90
2706:  MOVWF  FAB
2708:  BSF    FC1.0
270A:  BSF    FC1.1
270C:  BSF    FC1.2
270E:  BCF    FC1.3
2710:  BRA    2718
2712:  DATA 39,40
2714:  DATA 19,00
2716:  DATA 00,00
2718:  MOVLW  00
271A:  MOVWF  FF8
271C:  MOVLW  27
271E:  MOVWF  FF7
2720:  MOVLW  12
2722:  MOVWF  FF6
2724:  TBLRD*+
2726:  MOVF   FF5,W
2728:  MOVWF  00
272A:  XORLW  00
272C:  BZ    2754
272E:  TBLRD*+
2730:  MOVF   FF5,W
2732:  MOVWF  01
2734:  BTFSC  FE8.7
2736:  BRA    2742
2738:  ANDLW  0F
273A:  MOVWF  FEA
273C:  TBLRD*+
273E:  MOVFF  FF5,FE9
2742:  BTFSC  01.6
2744:  TBLRD*+
2746:  BTFSS  01.6
2748:  TBLRD*+
274A:  MOVFF  FF5,FEE
274E:  DCFSNZ 00,F
2750:  BRA    2724
2752:  BRA    2746
2754:  CLRF   FF8
2756:  CLRF   x79
2758:  CLRF   x78
275A:  CLRF   x77
275C:  MOVLW  17
275E:  MOVWF  x76
2760:  CLRF   x7D
2762:  CLRF   x7C
2764:  CLRF   x7B
2766:  MOVLW  19
2768:  MOVWF  x7A
276A:  BCF    x7E.0
276C:  BSF    x7E.1
276E:  MOVLW  08
2770:  MOVWF  x7F
2772:  MOVLW  03
2774:  MOVWF  x80
2776:  CLRF   x82
....................    //setup_spi(SPI_MASTER | SPI_MODE_1 | SPI_CLK_DIV_64, );  
....................    struct rx_stat rxstat; 
....................    int32 rx_id; 
....................    int in_data[8]; 
....................    int rx_len; 
....................  
.................... //send a request (tx_rtr=1) for 8 bytes of data (tx_len=8) from id 24 (tx_id=24) 
....................    int out_data[8]; 
....................    int out_data_hu[8]; 
....................    int32 tx_id=23; // id = 0x23 for temperature and pressure 
....................    int32 tx_idh =25; // id= 0x25 for humidity 
....................    
....................    int1 tx_rtr=0;// CU LA 1 
....................    int1 tx_ext=1;// CU LA 0 
....................    int tx_len=8; 
....................    int tx_pri=3; 
....................  
....................    int i; 
....................    int j = 0; 
....................    
....................    for (i=0;i<8;i++) { 
2778:  CLRF   x81
277A:  MOVF   x81,W
277C:  SUBLW  07
277E:  BNC   27B6
....................       out_data[i]=0x22; 
2780:  CLRF   03
2782:  MOVF   x81,W
2784:  ADDLW  66
2786:  MOVWF  FE9
2788:  MOVLW  00
278A:  ADDWFC 03,W
278C:  MOVWF  FEA
278E:  MOVLW  22
2790:  MOVWF  FEF
....................       in_data[i]=0; 
2792:  CLRF   03
2794:  MOVF   x81,W
2796:  ADDLW  5D
2798:  MOVWF  FE9
279A:  MOVLW  00
279C:  ADDWFC 03,W
279E:  MOVWF  FEA
27A0:  CLRF   FEF
....................       out_data_hu[i]=0; 
27A2:  CLRF   03
27A4:  MOVF   x81,W
27A6:  ADDLW  6E
27A8:  MOVWF  FE9
27AA:  MOVLW  00
27AC:  ADDWFC 03,W
27AE:  MOVWF  FEA
27B0:  CLRF   FEF
27B2:  INCF   x81,F
27B4:  BRA    277A
....................       
....................    } 
....................  
....................  //////////////////// 
.................... union conv {  
....................     float f;  
....................     int8 b[4];  
....................   }; 
....................   union conv tempp, pressp, hup;  // p is alias pointer 
....................  
.................... out_data[0] = tempp.b[0]; 
27B6:  MOVFF  83,66
.................... out_data[1] = tempp.b[1]; 
27BA:  MOVFF  84,67
.................... out_data[2] = tempp.b[2]; 
27BE:  MOVFF  85,68
.................... out_data[3] = tempp.b[3]; 
27C2:  MOVFF  86,69
....................  
.................... out_data[4] = pressp.b[0]; 
27C6:  MOVFF  87,6A
.................... out_data[5] = pressp.b[1]; 
27CA:  MOVFF  88,6B
.................... out_data[6] = pressp.b[2]; 
27CE:  MOVFF  89,6C
.................... out_data[7] = pressp.b[3]; 
27D2:  MOVFF  8A,6D
....................  
.................... out_data_hu[0] = hup.b[0]; 
27D6:  MOVFF  8B,6E
.................... out_data_hu[1] = hup.b[1]; 
27DA:  MOVFF  8C,6F
.................... out_data_hu[2] = hup.b[2]; 
27DE:  MOVFF  8D,70
.................... out_data_hu[3] = hup.b[3]; 
27E2:  MOVFF  8E,71
....................  
....................  
.................... //printf(" %4.4f : %x : %x : %x : %x \r\n",val2.f,\  
.................... //    val2.b[0],val2.b[1],val2.b[2],val2.b[3]);  
.................... //    //The new float value, and the bytes that make it.  
....................  
....................  ////////////////////  
....................  float temp,press,hu, thermo,thermo1; 
....................    printf("\r\n\r\nCCS CAN TRANSFER BME280 DATA\r\n"); 
27E6:  MOVLW  BA
27E8:  MOVWF  FF6
27EA:  MOVLW  00
27EC:  MOVWF  FF7
27EE:  CALL   021C
....................  
....................    setup_timer_2(T2_DIV_BY_4,79,16);   //setup up timer2 to interrupt every 1ms if using 20Mhz clock 
27F2:  MOVLW  78
27F4:  IORLW  05
27F6:  MOVWF  FCA
27F8:  MOVLW  4F
27FA:  MOVWF  FCB
....................  
....................    can_init(); 
27FC:  GOTO   03C0
....................    init_BME280(); 
2800:  GOTO   049C
....................    BME280Begin(); 
2804:  GOTO   085C
....................    delay_ms(200); 
2808:  MOVLW  C8
280A:  MOVWF  xA4
280C:  CALL   05CA
....................    
....................     
....................   // can_set_mode(CAN_OP_LOOPBACK); 
....................    
....................    enable_interrupts(INT_TIMER2);   //enable timer2 interrupt 
2810:  BSF    F9D.1
....................    enable_interrupts(GLOBAL);       //enable all interrupts (else timer2 wont happen) 
2812:  MOVLW  C0
2814:  IORWF  FF2,F
....................  
....................    printf("\r\nRunning..."); 
2816:  MOVLW  DE
2818:  MOVWF  FF6
281A:  MOVLW  00
281C:  MOVWF  FF7
281E:  CALL   021C
....................     
....................     
....................    while(TRUE) 
....................    {    
....................         BurstRead(); 
2822:  GOTO   08A0
....................         delay_ms(200); 
2826:  MOVLW  C8
2828:  MOVWF  xA4
282A:  CALL   05CA
....................         //out_data[0] = BME280ReadByte(0xD0); 
....................         //delay_ms(50); 
....................         //printf("\r\ID=%X", out_data[0]); 
....................         //delay_ms(10); 
....................         temp = BME280ReadTemperature(); 
282E:  GOTO   0B48
2832:  MOVFF  03,92
2836:  MOVFF  02,91
283A:  MOVFF  01,90
283E:  MOVFF  00,8F
....................         tempp.f = temp; 
2842:  MOVFF  92,86
2846:  MOVFF  91,85
284A:  MOVFF  90,84
284E:  MOVFF  8F,83
....................         out_data[0] = tempp.b[0]; 
2852:  MOVFF  83,66
....................         out_data[1] = tempp.b[1]; 
2856:  MOVFF  84,67
....................         out_data[2] = tempp.b[2]; 
285A:  MOVFF  85,68
....................         out_data[3] = tempp.b[3]; 
285E:  MOVFF  86,69
....................         delay_ms(10); 
2862:  MOVLW  0A
2864:  MOVWF  xA4
2866:  CALL   05CA
....................         printf("\r\nTemp_BME280 = %f3",temp); 
286A:  MOVLW  EC
286C:  MOVWF  FF6
286E:  MOVLW  00
2870:  MOVWF  FF7
2872:  MOVLW  10
2874:  MOVWF  xA7
2876:  CALL   0E82
287A:  MOVLW  89
287C:  MOVWF  FE9
287E:  MOVFF  92,A6
2882:  MOVFF  91,A5
2886:  MOVFF  90,A4
288A:  MOVFF  8F,A3
288E:  MOVLW  02
2890:  MOVWF  xA7
2892:  CALL   1062
2896:  MOVLW  33
2898:  BTFSS  F9E.4
289A:  BRA    2898
289C:  MOVWF  FAD
....................         hu = BME280ReadHumidity(); 
289E:  GOTO   11E2
28A2:  MOVFF  03,9A
28A6:  MOVFF  02,99
28AA:  MOVFF  01,98
28AE:  MOVFF  00,97
....................         delay_ms(20); 
28B2:  MOVLW  14
28B4:  MOVWF  xA4
28B6:  CALL   05CA
....................         hup.f = hu; 
28BA:  MOVFF  9A,8E
28BE:  MOVFF  99,8D
28C2:  MOVFF  98,8C
28C6:  MOVFF  97,8B
....................          out_data_hu[0] = hup.b[0]; 
28CA:  MOVFF  8B,6E
....................          out_data_hu[1] = hup.b[1]; 
28CE:  MOVFF  8C,6F
....................          out_data_hu[2] = hup.b[2]; 
28D2:  MOVFF  8D,70
....................          out_data_hu[3] = hup.b[3]; 
28D6:  MOVFF  8E,71
....................         printf("\r\nHumidityBME280 = %f3",hu); 
28DA:  MOVLW  00
28DC:  MOVWF  FF6
28DE:  MOVLW  01
28E0:  MOVWF  FF7
28E2:  MOVLW  13
28E4:  MOVWF  xA7
28E6:  CALL   0E82
28EA:  MOVLW  89
28EC:  MOVWF  FE9
28EE:  MOVFF  9A,A6
28F2:  MOVFF  99,A5
28F6:  MOVFF  98,A4
28FA:  MOVFF  97,A3
28FE:  MOVLW  02
2900:  MOVWF  xA7
2902:  CALL   1062
2906:  MOVLW  33
2908:  BTFSS  F9E.4
290A:  BRA    2908
290C:  MOVWF  FAD
....................         press = Calculate_Pess(); 
290E:  GOTO   1B40
2912:  MOVFF  03,96
2916:  MOVFF  02,95
291A:  MOVFF  01,94
291E:  MOVFF  00,93
....................         pressp.f = press; 
2922:  MOVFF  96,8A
2926:  MOVFF  95,89
292A:  MOVFF  94,88
292E:  MOVFF  93,87
....................          out_data[4] = pressp.b[0]; 
2932:  MOVFF  87,6A
....................          out_data[5] = pressp.b[1]; 
2936:  MOVFF  88,6B
....................          out_data[6] = pressp.b[2]; 
293A:  MOVFF  89,6C
....................          out_data[7] = pressp.b[3]; 
293E:  MOVFF  8A,6D
....................         delay_ms(20); 
2942:  MOVLW  14
2944:  MOVWF  xA4
2946:  CALL   05CA
....................         printf("\r\nTPressBME280 = %f3",press); 
294A:  MOVLW  18
294C:  MOVWF  FF6
294E:  MOVLW  01
2950:  MOVWF  FF7
2952:  MOVLW  11
2954:  MOVWF  xA7
2956:  CALL   0E82
295A:  MOVLW  89
295C:  MOVWF  FE9
295E:  MOVFF  96,A6
2962:  MOVFF  95,A5
2966:  MOVFF  94,A4
296A:  MOVFF  93,A3
296E:  MOVLW  02
2970:  MOVWF  xA7
2972:  CALL   1062
2976:  MOVLW  33
2978:  BTFSS  F9E.4
297A:  BRA    2978
297C:  MOVWF  FAD
....................         
....................  
....................           delay_ms(10); 
297E:  MOVLW  0A
2980:  MOVWF  xA4
2982:  CALL   05CA
....................        // printf("\r\nThermocouple 1 = %f", thermo1); 
....................         BME280WriteByte(0xF4,0x6E); 
2986:  MOVLW  F4
2988:  MOVWF  xA3
298A:  MOVLW  6E
298C:  MOVWF  xA4
298E:  CALL   0590
....................       if ( can_kbhit() )   //if data is waiting in buffer... 
2992:  BTFSC  F60.7
2994:  BRA    299E
2996:  MOVLB  F
2998:  BTFSS  x50.7
299A:  BRA    2C1E
299C:  MOVLB  0
....................       { 
....................          if(can_getd(rx_id, &in_data[0], rx_len, rxstat)) { //...then get data from buffer 
299E:  CLRF   xA4
29A0:  MOVLW  5D
29A2:  MOVWF  xA3
*
2AA0:  MOVF   01,F
2AA2:  BTFSC  FD8.2
2AA4:  BRA    2C0E
....................             printf("\r\nGOT: BUFF=%U ID=%LU LEN=%U OVF=%U ", rxstat.buffer, rx_id, rx_len, rxstat.err_ovfl); 
2AA6:  MOVLW  00
2AA8:  BTFSC  58.4
2AAA:  MOVLW  01
2AAC:  MOVLB  0
2AAE:  MOVWF  xA3
2AB0:  MOVLW  00
2AB2:  BTFSC  58.0
2AB4:  MOVLW  01
2AB6:  MOVWF  xA4
2AB8:  MOVLW  2E
2ABA:  MOVWF  FF6
2ABC:  MOVLW  01
2ABE:  MOVWF  FF7
2AC0:  MOVLW  0C
2AC2:  MOVWF  xA7
2AC4:  CALL   0E82
2AC8:  MOVFF  A3,A7
2ACC:  MOVLW  1B
2ACE:  MOVWF  xA8
2AD0:  RCALL  24D2
2AD2:  MOVLW  3C
2AD4:  MOVWF  FF6
2AD6:  MOVLW  01
2AD8:  MOVWF  FF7
2ADA:  MOVLW  04
2ADC:  MOVWF  xA7
2ADE:  CALL   0E82
2AE2:  MOVLW  41
2AE4:  MOVWF  FE9
2AE6:  MOVFF  5C,A8
2AEA:  MOVFF  5B,A7
2AEE:  MOVFF  5A,A6
2AF2:  MOVFF  59,A5
2AF6:  RCALL  253E
2AF8:  MOVLW  43
2AFA:  MOVWF  FF6
2AFC:  MOVLW  01
2AFE:  MOVWF  FF7
2B00:  MOVLW  05
2B02:  MOVWF  xA7
2B04:  CALL   0E82
2B08:  MOVFF  65,A7
2B0C:  MOVLW  1B
2B0E:  MOVWF  xA8
2B10:  RCALL  24D2
2B12:  MOVLW  4A
2B14:  MOVWF  FF6
2B16:  MOVLW  01
2B18:  MOVWF  FF7
2B1A:  MOVLW  05
2B1C:  MOVWF  xA7
2B1E:  CALL   0E82
2B22:  MOVFF  A4,A7
2B26:  MOVLW  1B
2B28:  MOVWF  xA8
2B2A:  RCALL  24D2
2B2C:  MOVLW  20
2B2E:  BTFSS  F9E.4
2B30:  BRA    2B2E
2B32:  MOVWF  FAD
....................             printf("FILT=%U RTR=%U EXT=%U INV=%U", rxstat.filthit, rxstat.rtr, rxstat.ext, rxstat.inv); 
2B34:  MOVFF  58,00
2B38:  RRCF   58,W
2B3A:  ANDLW  07
2B3C:  MOVWF  xA3
2B3E:  MOVLW  00
2B40:  BTFSC  58.5
2B42:  MOVLW  01
2B44:  MOVWF  xA4
2B46:  MOVLW  00
2B48:  BTFSC  58.6
2B4A:  MOVLW  01
2B4C:  MOVWF  xA5
2B4E:  MOVLW  00
2B50:  BTFSC  58.7
2B52:  MOVLW  01
2B54:  MOVWF  xA6
2B56:  MOVLW  54
2B58:  MOVWF  FF6
2B5A:  MOVLW  01
2B5C:  MOVWF  FF7
2B5E:  MOVLW  05
2B60:  MOVWF  xA7
2B62:  CALL   0E82
2B66:  MOVFF  A3,A7
2B6A:  MOVLW  1B
2B6C:  MOVWF  xA8
2B6E:  RCALL  24D2
2B70:  MOVLW  5B
2B72:  MOVWF  FF6
2B74:  MOVLW  01
2B76:  MOVWF  FF7
2B78:  MOVLW  05
2B7A:  MOVWF  xA7
2B7C:  CALL   0E82
2B80:  MOVFF  A4,A7
2B84:  MOVLW  1B
2B86:  MOVWF  xA8
2B88:  RCALL  24D2
2B8A:  MOVLW  62
2B8C:  MOVWF  FF6
2B8E:  MOVLW  01
2B90:  MOVWF  FF7
2B92:  MOVLW  05
2B94:  MOVWF  xA7
2B96:  CALL   0E82
2B9A:  MOVFF  A5,A7
2B9E:  MOVLW  1B
2BA0:  MOVWF  xA8
2BA2:  RCALL  24D2
2BA4:  MOVLW  69
2BA6:  MOVWF  FF6
2BA8:  MOVLW  01
2BAA:  MOVWF  FF7
2BAC:  MOVLW  05
2BAE:  MOVWF  xA7
2BB0:  CALL   0E82
2BB4:  MOVFF  A6,A7
2BB8:  MOVLW  1B
2BBA:  MOVWF  xA8
2BBC:  RCALL  24D2
....................             printf("\r\n    DATA = "); 
2BBE:  MOVLW  72
2BC0:  MOVWF  FF6
2BC2:  MOVLW  01
2BC4:  MOVWF  FF7
2BC6:  CALL   021C
....................             for (i=0;i<rx_len;i++) { 
2BCA:  CLRF   x81
2BCC:  MOVF   x65,W
2BCE:  SUBWF  x81,W
2BD0:  BC    2BFA
....................                printf("%X ",in_data[i]); 
2BD2:  CLRF   03
2BD4:  MOVF   x81,W
2BD6:  ADDLW  5D
2BD8:  MOVWF  FE9
2BDA:  MOVLW  00
2BDC:  ADDWFC 03,W
2BDE:  MOVWF  FEA
2BE0:  MOVFF  FEF,A3
2BE4:  MOVFF  A3,A4
2BE8:  MOVLW  37
2BEA:  MOVWF  xA5
2BEC:  RCALL  25E8
2BEE:  MOVLW  20
2BF0:  BTFSS  F9E.4
2BF2:  BRA    2BF0
2BF4:  MOVWF  FAD
2BF6:  INCF   x81,F
2BF8:  BRA    2BCC
....................             } 
....................             printf("\r\n"); 
2BFA:  MOVLW  0D
2BFC:  BTFSS  F9E.4
2BFE:  BRA    2BFC
2C00:  MOVWF  FAD
2C02:  MOVLW  0A
2C04:  BTFSS  F9E.4
2C06:  BRA    2C04
2C08:  MOVWF  FAD
....................          } 
2C0A:  BRA    2C1C
2C0C:  MOVLB  F
....................          else { 
....................             printf("\r\nFAIL on GETD\r\n"); 
2C0E:  MOVLW  80
2C10:  MOVWF  FF6
2C12:  MOVLW  01
2C14:  MOVWF  FF7
2C16:  MOVLB  0
2C18:  CALL   021C
2C1C:  MOVLB  F
....................          } 
....................  
....................       } 
....................       //every two seconds, send new data if transmit buffer is empty 
....................       if ( can_tbe() && (ms > 2000)) 
2C1E:  BTFSS  x40.3
2C20:  BRA    2C2A
2C22:  BTFSS  x30.3
2C24:  BRA    2C2A
2C26:  BTFSC  x20.3
2C28:  BRA    2F3C
2C2A:  MOVF   57,W
2C2C:  SUBLW  06
2C2E:  BTFSC  FD8.0
2C30:  BRA    2F3C
2C32:  XORLW  FF
2C34:  BNZ   2C3E
2C36:  MOVF   56,W
2C38:  SUBLW  D0
2C3A:  BTFSC  FD8.0
2C3C:  BRA    2F3C
....................       { 
....................          ms=0; 
2C3E:  CLRF   57
2C40:  CLRF   56
....................          i=can_putd(tx_id, out_data, tx_len,tx_pri,tx_ext,tx_rtr); //put data on transmit buffer 
2C42:  MOVLW  00
2C44:  MOVLB  0
2C46:  BTFSC  x7E.1
2C48:  MOVLW  01
2C4A:  MOVWF  xA3
2C4C:  MOVLW  00
2C4E:  BTFSC  x7E.0
2C50:  MOVLW  01
2C52:  MOVWF  xA4
2C54:  MOVFF  79,A8
2C58:  MOVFF  78,A7
2C5C:  MOVFF  77,A6
2C60:  MOVFF  76,A5
2C64:  CLRF   xAA
2C66:  MOVLW  66
2C68:  MOVWF  xA9
2C6A:  MOVFF  7F,AB
2C6E:  MOVFF  80,AC
2C72:  MOVFF  A3,AD
2C76:  MOVFF  A4,AE
2C7A:  RCALL  262A
2C7C:  MOVFF  01,81
....................          if (i != 0xFF) { //success, a transmit buffer was open 
2C80:  INCFSZ x81,W
2C82:  BRA    2C86
2C84:  BRA    2DB0
....................             printf("\r\nPUT %U: ID=%LU LEN=%U ", i, tx_id, tx_len);  //i return 1 if transmit success 
2C86:  MOVLW  92
2C88:  MOVWF  FF6
2C8A:  MOVLW  01
2C8C:  MOVWF  FF7
2C8E:  MOVLW  06
2C90:  MOVWF  xA7
2C92:  CALL   0E82
2C96:  MOVFF  81,A7
2C9A:  MOVLW  1B
2C9C:  MOVWF  xA8
2C9E:  RCALL  24D2
2CA0:  MOVLW  9A
2CA2:  MOVWF  FF6
2CA4:  MOVLW  01
2CA6:  MOVWF  FF7
2CA8:  MOVLW  05
2CAA:  MOVWF  xA7
2CAC:  CALL   0E82
2CB0:  MOVLW  41
2CB2:  MOVWF  FE9
2CB4:  MOVFF  79,A8
2CB8:  MOVFF  78,A7
2CBC:  MOVFF  77,A6
2CC0:  MOVFF  76,A5
2CC4:  RCALL  253E
2CC6:  MOVLW  A2
2CC8:  MOVWF  FF6
2CCA:  MOVLW  01
2CCC:  MOVWF  FF7
2CCE:  MOVLW  05
2CD0:  MOVWF  xA7
2CD2:  CALL   0E82
2CD6:  MOVFF  7F,A7
2CDA:  MOVLW  1B
2CDC:  MOVWF  xA8
2CDE:  CALL   24D2
2CE2:  MOVLW  20
2CE4:  BTFSS  F9E.4
2CE6:  BRA    2CE4
2CE8:  MOVWF  FAD
....................             printf("PRI=%U EXT=%U RTR=%U\r\n   DATA = ", tx_pri, tx_ext, tx_rtr); 
2CEA:  MOVLW  00
2CEC:  BTFSC  x7E.1
2CEE:  MOVLW  01
2CF0:  MOVWF  xA3
2CF2:  MOVLW  00
2CF4:  BTFSC  x7E.0
2CF6:  MOVLW  01
2CF8:  MOVWF  xA4
2CFA:  MOVLW  AC
2CFC:  MOVWF  FF6
2CFE:  MOVLW  01
2D00:  MOVWF  FF7
2D02:  MOVLW  04
2D04:  MOVWF  xA7
2D06:  CALL   0E82
2D0A:  MOVFF  80,A7
2D0E:  MOVLW  1B
2D10:  MOVWF  xA8
2D12:  CALL   24D2
2D16:  MOVLW  B2
2D18:  MOVWF  FF6
2D1A:  MOVLW  01
2D1C:  MOVWF  FF7
2D1E:  MOVLW  05
2D20:  MOVWF  xA7
2D22:  CALL   0E82
2D26:  MOVFF  A3,A7
2D2A:  MOVLW  1B
2D2C:  MOVWF  xA8
2D2E:  CALL   24D2
2D32:  MOVLW  B9
2D34:  MOVWF  FF6
2D36:  MOVLW  01
2D38:  MOVWF  FF7
2D3A:  MOVLW  05
2D3C:  MOVWF  xA7
2D3E:  CALL   0E82
2D42:  MOVFF  A4,A7
2D46:  MOVLW  1B
2D48:  MOVWF  xA8
2D4A:  CALL   24D2
2D4E:  MOVLW  C0
2D50:  MOVWF  FF6
2D52:  MOVLW  01
2D54:  MOVWF  FF7
2D56:  MOVLW  0C
2D58:  MOVWF  xA7
2D5A:  CALL   0E82
....................             //  printf("\r\nID=%X", out_data[0]); 
....................             for (i=0;i<tx_len;i++) { 
2D5E:  CLRF   x81
2D60:  MOVF   x7F,W
2D62:  SUBWF  x81,W
2D64:  BC    2D9E
....................                printf("\r\n%X ",out_data[i]); 
2D66:  CLRF   03
2D68:  MOVF   x81,W
2D6A:  ADDLW  66
2D6C:  MOVWF  FE9
2D6E:  MOVLW  00
2D70:  ADDWFC 03,W
2D72:  MOVWF  FEA
2D74:  MOVFF  FEF,A3
2D78:  MOVLW  0D
2D7A:  BTFSS  F9E.4
2D7C:  BRA    2D7A
2D7E:  MOVWF  FAD
2D80:  MOVLW  0A
2D82:  BTFSS  F9E.4
2D84:  BRA    2D82
2D86:  MOVWF  FAD
2D88:  MOVFF  A3,A4
2D8C:  MOVLW  37
2D8E:  MOVWF  xA5
2D90:  RCALL  25E8
2D92:  MOVLW  20
2D94:  BTFSS  F9E.4
2D96:  BRA    2D94
2D98:  MOVWF  FAD
2D9A:  INCF   x81,F
2D9C:  BRA    2D60
....................             } 
....................             printf("\r\n"); 
2D9E:  MOVLW  0D
2DA0:  BTFSS  F9E.4
2DA2:  BRA    2DA0
2DA4:  MOVWF  FAD
2DA6:  MOVLW  0A
2DA8:  BTFSS  F9E.4
2DAA:  BRA    2DA8
2DAC:  MOVWF  FAD
....................          } 
2DAE:  BRA    2DBC
....................          else { //fail, no transmit buffer was open 
....................             printf("\r\nFAIL on PUTD\r\n"); 
2DB0:  MOVLW  CE
2DB2:  MOVWF  FF6
2DB4:  MOVLW  01
2DB6:  MOVWF  FF7
2DB8:  CALL   021C
....................          
....................          } 
....................          j=can_putd(tx_idh, out_data_hu, tx_len,tx_pri,tx_ext,tx_rtr); //put data on transmit buffer 
2DBC:  MOVLW  00
2DBE:  BTFSC  x7E.1
2DC0:  MOVLW  01
2DC2:  MOVWF  xA3
2DC4:  MOVLW  00
2DC6:  BTFSC  x7E.0
2DC8:  MOVLW  01
2DCA:  MOVWF  xA4
2DCC:  MOVFF  7D,A8
2DD0:  MOVFF  7C,A7
2DD4:  MOVFF  7B,A6
2DD8:  MOVFF  7A,A5
2DDC:  CLRF   xAA
2DDE:  MOVLW  6E
2DE0:  MOVWF  xA9
2DE2:  MOVFF  7F,AB
2DE6:  MOVFF  80,AC
2DEA:  MOVFF  A3,AD
2DEE:  MOVFF  A4,AE
2DF2:  RCALL  262A
2DF4:  MOVFF  01,82
....................          if(j != 0xFF) 
2DF8:  INCFSZ x82,W
2DFA:  BRA    2DFE
2DFC:  BRA    2F2C
....................          { 
....................             printf("\r\nPUT %U: ID=%LU LEN=%U ", i, tx_id, tx_len);  //i return 1 if transmit success 
2DFE:  MOVLW  E0
2E00:  MOVWF  FF6
2E02:  MOVLW  01
2E04:  MOVWF  FF7
2E06:  MOVLW  06
2E08:  MOVWF  xA7
2E0A:  CALL   0E82
2E0E:  MOVFF  81,A7
2E12:  MOVLW  1B
2E14:  MOVWF  xA8
2E16:  CALL   24D2
2E1A:  MOVLW  E8
2E1C:  MOVWF  FF6
2E1E:  MOVLW  01
2E20:  MOVWF  FF7
2E22:  MOVLW  05
2E24:  MOVWF  xA7
2E26:  CALL   0E82
2E2A:  MOVLW  41
2E2C:  MOVWF  FE9
2E2E:  MOVFF  79,A8
2E32:  MOVFF  78,A7
2E36:  MOVFF  77,A6
2E3A:  MOVFF  76,A5
2E3E:  CALL   253E
2E42:  MOVLW  F0
2E44:  MOVWF  FF6
2E46:  MOVLW  01
2E48:  MOVWF  FF7
2E4A:  MOVLW  05
2E4C:  MOVWF  xA7
2E4E:  CALL   0E82
2E52:  MOVFF  7F,A7
2E56:  MOVLW  1B
2E58:  MOVWF  xA8
2E5A:  CALL   24D2
2E5E:  MOVLW  20
2E60:  BTFSS  F9E.4
2E62:  BRA    2E60
2E64:  MOVWF  FAD
....................             printf("PRI=%U EXT=%U RTR=%U\r\n   DATA = ", tx_pri, tx_ext, tx_rtr); 
2E66:  MOVLW  00
2E68:  BTFSC  x7E.1
2E6A:  MOVLW  01
2E6C:  MOVWF  xA3
2E6E:  MOVLW  00
2E70:  BTFSC  x7E.0
2E72:  MOVLW  01
2E74:  MOVWF  xA4
2E76:  MOVLW  FA
2E78:  MOVWF  FF6
2E7A:  MOVLW  01
2E7C:  MOVWF  FF7
2E7E:  MOVLW  04
2E80:  MOVWF  xA7
2E82:  CALL   0E82
2E86:  MOVFF  80,A7
2E8A:  MOVLW  1B
2E8C:  MOVWF  xA8
2E8E:  CALL   24D2
2E92:  MOVLW  00
2E94:  MOVWF  FF6
2E96:  MOVLW  02
2E98:  MOVWF  FF7
2E9A:  MOVLW  05
2E9C:  MOVWF  xA7
2E9E:  CALL   0E82
2EA2:  MOVFF  A3,A7
2EA6:  MOVLW  1B
2EA8:  MOVWF  xA8
2EAA:  CALL   24D2
2EAE:  MOVLW  07
2EB0:  MOVWF  FF6
2EB2:  MOVLW  02
2EB4:  MOVWF  FF7
2EB6:  MOVLW  05
2EB8:  MOVWF  xA7
2EBA:  CALL   0E82
2EBE:  MOVFF  A4,A7
2EC2:  MOVLW  1B
2EC4:  MOVWF  xA8
2EC6:  CALL   24D2
2ECA:  MOVLW  0E
2ECC:  MOVWF  FF6
2ECE:  MOVLW  02
2ED0:  MOVWF  FF7
2ED2:  MOVLW  0C
2ED4:  MOVWF  xA7
2ED6:  CALL   0E82
....................              for (j=0;j<tx_len;i++) { 
2EDA:  CLRF   x82
2EDC:  MOVF   x7F,W
2EDE:  SUBWF  x82,W
2EE0:  BC    2F1C
....................                printf("\r\n%X ",out_data_hu[i]); 
2EE2:  CLRF   03
2EE4:  MOVF   x81,W
2EE6:  ADDLW  6E
2EE8:  MOVWF  FE9
2EEA:  MOVLW  00
2EEC:  ADDWFC 03,W
2EEE:  MOVWF  FEA
2EF0:  MOVFF  FEF,A3
2EF4:  MOVLW  0D
2EF6:  BTFSS  F9E.4
2EF8:  BRA    2EF6
2EFA:  MOVWF  FAD
2EFC:  MOVLW  0A
2EFE:  BTFSS  F9E.4
2F00:  BRA    2EFE
2F02:  MOVWF  FAD
2F04:  MOVFF  A3,A4
2F08:  MOVLW  37
2F0A:  MOVWF  xA5
2F0C:  CALL   25E8
2F10:  MOVLW  20
2F12:  BTFSS  F9E.4
2F14:  BRA    2F12
2F16:  MOVWF  FAD
2F18:  INCF   x81,F
2F1A:  BRA    2EDC
....................             } 
....................             printf("\r\n"); 
2F1C:  MOVLW  0D
2F1E:  BTFSS  F9E.4
2F20:  BRA    2F1E
2F22:  MOVWF  FAD
2F24:  MOVLW  0A
2F26:  BTFSS  F9E.4
2F28:  BRA    2F26
2F2A:  MOVWF  FAD
....................          } 
....................           
....................     
....................        
....................      delay_ms(500);  
2F2C:  MOVLW  02
2F2E:  MOVWF  xA3
2F30:  MOVLW  FA
2F32:  MOVWF  xA4
2F34:  CALL   05CA
2F38:  DECFSZ xA3,F
2F3A:  BRA    2F30
....................    } 
2F3C:  MOVLB  0
2F3E:  BRA    2822
.................... } 
.................... } 
2F40:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   PUT BROWNOUT BORV25 NOWDT WDT128
   Word  3: 0000  
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
